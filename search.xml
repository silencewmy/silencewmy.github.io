<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM第四步——内存中的数据的如何使用]]></title>
    <url>%2F2018%2F10%2F19%2FJVM%E7%AC%AC%E4%B8%89%E6%AD%A5%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[第二步说到虚拟机的内存布局，那么虚拟机是如何将数据存放进相对应的区域的呢，这其中的过程又是什么呢。Java堆中对象的内存分配、布局和访问。 以Java程序中最多的对象的创建为例子。（其实时书中就是以此为例子^_^） 确定那一个类 遇到new指令后检查该指令的符号常量（是否被加载解析初始化），没有就先进行类的加载过程。 类加载检查后为其 分配内存（所需大小在类加载阶段完成后就可确定） 如何在堆中为对象划分内存 指针碰撞：Java堆内存是规整的，就是将分界指示器（空闲和使用过的）的指针向空闲侧移动。 空闲列表：内存不规整，维护一个可使用内存块的列表，划分是从列表中寻找一块足够使用的空间并更新空闲列表的记录。 两种划分方式取决于内存是否规整，而内存的规整取决于GC是否有压缩整理功能。 安全的在堆中为对象划分内存 JVM中对象的创建非常频繁导致并发下不是线程安全的（创建过程并非一步到位可以划分为很多步，可以被插队）。如正在为A分配空间，指针还未修改。此时对象B又使用此时的指针来分配内存。 堆分配空间的动作进行同步处理：CAS家失败重试来保证更新的原子性。一直尝试分配直到分配成功。 另一种从空间上来断绝修改相同区域的可能，不同线程给予不同的内存，不同线程在自己得到的内存中分配对象，这一块叫做本地线程分配缓冲。在线程共享的区域中分出线程私有的区域来实现线程安全的对象分配。 分配内存后，将内存区域初始化为零值。（实例字段不赋初始值是不能使用的）（不包括对象头）实例字段是通过对象去引用的。 虚拟机要对对象进行必要的设置，主要是对象头的设置。对象头如下 对象头主要分为两部分 Mark Word运行时数据（告知虚拟机如何来处理使用对象）这是额外开销与对象本身数据无关 运行时数据是一个非固定的可复用的数据结构空间，所以可以在小空间存储尽量多的内容。具体有如下 对象的哈希码：用来判断是否同一个对象，为对象的特征 GC分代年龄：通过分代年龄，虚拟机才知道如何去管理该片数据区域（后文的年龄限制进入老年区）。 指向锁的指针：锁优化中的轻量级锁，通过状态的改变来达到资源唯一使用性。 指向重量级锁的指针 偏向锁偏向的线程ID 等等都是方便虚拟机来使用对象，与对象本身所存储的数据无关。 类型指针 -确定对象属于那个类的实例的指向类元数据的指针 如果是数组对象那么对象头中有记录数组长度的数据，普通Java对象可以在类元数据中确定对象的大小。 至此在虚拟机看来对象已经生产出来了，只不过所有的变量都是零值不是程序员期望的值（init方法还未执行。），init方法执行后真正可用的对象才生产出来。 对象的内存布局 –对象在堆中到底是如何存放的针对虚拟机的不同会有不同，以HotSpot为例。对象在内存中存储的数据主要分为3部分： 对象头：在前面虚拟机对对象的设置时有介绍对象头。 实例数据 此部分存储的是真正有效的数据（程序中定义的各种字段内容） 父类继承，子类定义的都在这里 相同宽度的字段分配在一起，父类中的变量在子类之前。 对其填充 仅仅有占位符的作用，虚拟机自动内存管理系统要求地址必须是8字节的整数倍。 定位对象 –如何来访问堆中的对象 Java程序通过栈上的reference数据来操作堆上的具体对象。reference数据能做到两点 通过该引用可以访问该对象在堆中存放数据的起始地址。 通过该引用g可以对象所属的类的类型信息（在方法区，类加载机制将类加载进方法区中）。 reference只是一个指向对象的引用，并不是如何去定位、访问堆中的对象数据。 对象的访问方式取决于虚拟机实现，主流方式有如下两种： 句柄 Java堆中划分中一块区域作为句柄池，reference存储的就是对象的句柄地址。 句柄存储有： 对象的实例数据地址（堆中，对象内存布局中存储有效数据的实例数据） 类型数据（方法区中） 好处就是reference存储的一直是句柄地址，对象移动时只需改变句柄中的实例地址。 直接指针 存储的是对象的直接地址但是需要对象自己存储访问类型数据的地址（方法区中）。 好处就是速度快，一部到位。少一步指针定位（到句柄）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM第三步——class文件如何进入虚拟机]]></title>
    <url>%2F2018%2F10%2F18%2FJVM%E7%AC%AC%E5%9B%9B%E6%AD%A5%E2%80%94%E2%80%94class%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[class文件描述的各种信息需要加载到虚拟机才能运行和使用，将class文件转移到虚拟机中你需要知道它是如何转移，又转移到哪里。此处记录的是class文件如何进入虚拟机,class文件只有加载进虚拟机后才能使用。 ###虚拟机的类加载机制将描述类的信息的class文件加载到内存，并对数据进行校验、转换解析和初始化，形成虚拟机直接使用的Java类型。Java语言在程序运行时对类型进行加载、连接、初始化。Java语言的动态扩展特性依靠运行期动态加载和动态连接。类被加载到虚拟机内存中去和从内存中卸载出经历的生命周期为：加载、验证、准备、解析、初始化、使用、卸载这七个阶段。其中验证、准备、解析三个阶段统称为连接。加载、验证、准备、初始化和卸载必须有这种相对顺序，解析阶段可以在初始化之后再开始。 ####何时开始加载阶段呢？或者说何时进行初始化阶段 简单说就是使用时必须要初始化Java虚拟机并无规定何时开始加载阶段，但是严格规定如下5种（有且仅有）情况必须立即进行“初始化”阶段。按照严格的相对顺序，此时必须完成加载、验证、准备这三个阶段。 new（实例化对象的时候）、putstatic+getstatic(设置类的静态字段)、invokestatic（调用静态方法时），如未曾初始化该类需要先初始化。 对类进行反射调用，但该类没有进行初始化。 初始化类时发现其父类并未初始化 首先初始化用户在虚拟机启动时指定的主类。 动态使用的类未曾初始化。 ###类加载的全过程如下 ####加载阶段 –给JVM提供“原材料”要完成如下三件事情： 通过类的全限名获取该类的二进制字节流（可以理解为class文件，但是不止class文件） class文件 jsp应用等其他文件生成 从网络中获取 将字节流中的静态存储结构转换成方法区的运行时数据结构 生成代表该类的引用（Class类型的对象），这是这个类在方法区所有数据的访问入口。 class类型的对象虽然是对象，但是却存在于方法区中。 加载阶段的开发人员可控性强，可以自定义类加载器（可以控制字节流的获取方式）。类和该类的类加载器一起确定唯一性 类加载阶段完成后，JVM外部的二进制流就按照格式存储在方法区中了。 ####验证阶段 –自我保护的手段 验证阶段的主要目的：确保字节流文件中包含的信息符合JVM的要求，如果不符合规范要求则抛出异常 因为class文件不全是Java源码文件编译出来。如果不检查合法性会因有害的字节流导致系统崩溃。 具有大量约束和验证规则的规范 验证阶段完成下面4个动作： 文件格式验证 –验查索引处是否有正确值，是否符合编码要求 验证字节（检验的对象是二进制字节流）流是否符合class文件的格式规范。通过该检验后字节流才能进入方法区。 主要目的是确保输入的字节流能正确的解析 魔数 版本号 指向常量池的索引值是否都有了正确的常量 后面的三个验证阶段都欧式基于方法区，只有文件格式验证是基于二进制字节流 元数据验证 –元数据的数据类型校验 对类的元数据进行语义校验 检查是否有父类，是否继承了不允许被继承的类 字节码验证 –对类的方法进行校验 主要目的是确定程序语义是合法的、符合逻辑的 操作栈中的与指令的对应 跳转指令不会跳到错误的地方 为节省时间将验证阶段的“推导状态的动作提前”，在编译阶段将方法的本地变量表和操作栈的状态存储进StackMapTable中，验证时只需检验该属性的合法性即可。 符号引用验证 –保证解析动作能够正常执行 在将符号引用转换成直接引用的时候进行验证 就是对常量池中的符号引用进行匹配性校验，保证都能找到且找到的都是正确的。 验证符号引用的访问权限（是否可以被当前类访问）。 准备阶段 -正式为类变量分配内存区域并设置初始值 是在方法区中为类变量（被static修饰的变量）分配区域，并设置初始值 实例变量会随对象实例化时分配在Java堆中 如若字段属性中有ConstantValue存在，则会为static变量设置值。 解析阶段 -将符号引用替换为直接应用的阶段 符号引用 一组符号（可以说是字符串）用来唯一描述所引用过的目标 所引用的目标不一定是已经加载到内存中 直接引用 与虚拟机的内存分布相关 所引用的目标的实际存储地址 指向目标的指针 能间接定位目标的句柄 或者能定位到目标的偏移量 没有规定解析阶段的具体时间，表示在执行（操作符号引用的）指令之前对符号引用进行解析。 对符号引用的解析可能会有多次，除动态调用外，解析结果可缓存。 解析阶段主要对7种符号引用进行解析 类或者接口 将不是数组类型的类的符号引用交给使用它的类的类加载器（即两个类使用同一个类加载器） 数组类型的的每个元素按照上面的方式解析，最后由虚拟机生成数组对象。 解析完成前进行符号引用验证，验证是否具有访问权限。无访问权限抛出异常。 字段解析 首先要求就是对该字段所属类的符号引用已经被解析。 按照从该类、（继承关系的从下往上）接口、父类搜索该字段相同简单名称和描述符的字段 上述都搜索不到时抛出错误 如若该字段同时出现在自己父类或者接口中时，编译器拒绝编译并抛出异常。 类方法解析 首先确保该类方法所属的类已经被解析 按照该类、父类、（递归的从下到上的搜索）接口 找到返回直接引用，没找到抛出异常。 接口方法解析 同样要确保所属类或接口的符号引用被解析 判断该引用是否为接口，如若不是则抛出异常 在其父接口中递归查找 方法类型 方法句柄 调用点限定符 初始化阶段 -真正执行类中定义的Java程序代码 按照程序员意愿去初始化类变量（准备阶段时设置初始值并不是程序员赋予的值）和其他资源。 可以说初始化阶段就是执行类构造器方法(clinit)的过程 clinit方法的形成： 编译器自动收集类中的类变量的赋值动作和静态语句块中的语句合并而成，按照出现顺序。 以上就是将class文件加载进虚拟机的过程也可以说时将class字节流从固态存储地移动到动态内存来给虚拟机使用的过程。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM第二步————class文件在虚拟机中的目的地]]></title>
    <url>%2F2018%2F10%2F18%2FJVM%E7%AC%AC%E4%BA%8C%E6%AD%A5%E2%80%94%E2%80%94class%E6%96%87%E4%BB%B6%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[class文件描述的各种信息需要加载到虚拟机才能运行和使用，将class文件转移到虚拟机中你需要知道它是如何转移，又转移到哪里。此处说明转移到哪里 Java虚拟机将从系统得到的内存划分为不同区域来完成不同的用途，虚拟机采用自动内存管理机制使得我们不用为我们使用的class文件来分配空间，不同的数据区域有着不同的创建和销毁时间。 ###虚拟机的运行时数据区域这是主要的class文件进入虚拟机要存放的地方，它有如下几个区域： 程序计数器 虚拟机栈 本地方法栈 方法区 堆 ####程序计数器 –线程私有使用的空间较小，是字节码行号指示器来选区下一条指令。每个线程都有自己独立的程序计数器来保证多线程可以顺利的执行（切换到正确的执行位置）。唯一一个不涉及OOM情况的区域 ####虚拟机栈 –线程私有描述的是Java方法执行的内存模型，也就是方法整个执行过程都在这里。每一个方法的内容总会有数据的操作，这一区域实现的就是把所有这个方法要使用的数据保存进来然后进行想要的处理得出结果的过程。每一个栈帧对应一个方法，每个方法从调用到执行完成的过程对应着一个栈帧在虚拟机栈中的入栈和出栈。那么栈帧是什么呢。。 #####栈帧 –一种数据结构，用来支持方法的调用和方法的执行，方法运行时所有的信息。在编译程序代码的时候，栈帧需要多大的局部变量表，多深的操作栈都已经确定好了，在方法表的Code属性中，因此一个栈帧需要多大的内存已经确定，不会受到运行期数据的影响。线程中的方法调用链很长，有多个方法处于执行状态（就是入栈了），但只有位于栈顶的栈帧才有效栈帧包括这几个部分： 局部变量表 用来存储方法局部变量和方法参数的一组存储空间。 以变量槽作为单位（slot），64位用连续的两个slot 通过索引定位的方式来使用局部变量表，索引范围从0到最大容量数（Code属性中） 虚拟机是使用局部变量表来完成参数值到参数列表的传递 局部变量中的存储空间是可以被重用的（针对的是方法体中定义的变量） 局部变量的存储也是有顺序的，按照如下顺序来存放： 方法所属的对象的引用，也就是this 存放在索引0处 然后是方法表的参数表中的参数顺序 而后是方法体中定义的变量顺序和作用域来分配 除存储基本数据类型外，存储一个reference类型来表示对象的实例引用作用： 通过该引用可以直接或者间接的查找到该对象在堆中的数据存放的起始地址 直接或者间接的查找到对象对应的在方法区中的类型信息 局部变量定义后不赋初始值是不能使用的 操作数栈 最大深度在编译期写在方法表中的Code属性中 在方法执行过程中操作栈深度不会超过上面的最大深度 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，因为Java字节码指令是面向操作栈的，指令中会限制要操作的数据的类型。 针对操作栈的优化：两个栈帧出现部分重叠（下面栈帧的部分操作数栈与上面的部分局部变量表重叠），在方法调用的过程中公用一些数据来减少参数的复制。 动态连接 每个栈帧（方法，因为一个栈帧代表一个方法）指向运行时常量池的引用，也就是所属方法的引用。 动态连接是什么：class文件中的符号引用在每一次的运行期间转换为直接引用称为动态连接 方法返回地址 方法的两种退出方式 正常完成出口：遇到任意方法返回指令，返回给调用者。 异常完成出口：方法遇到的异常没有匹配到异常处理器（class文件中Code属性中的异常处理表和方法表中的Exceptions属性所罗列的异常），此种方式不会给上层调用者产生任何返回值。 虚拟机栈会抛出的异常： 线程请求栈深度大于虚拟机栈允许的最大深度抛出 StackOverflowError异常 虚拟机栈在动态扩展时无法申请到足够的内存就会抛出 OOMError异常 本地方法栈 –类似栈而服务不同对象虚拟机栈为执行Java方法服务，本地方法栈为执行非Java方法（Native方法）服务。抛出的异常也和虚拟机栈一般。 Java堆 –所有线程共享的一块区域，在虚拟机启动时创建 new即会在堆上分配内存 唯一目的：存放对象实例。 虚拟机规范中“所有的对象实例和数组都要在堆上分配”。 垃圾收集器管理的主要区域。 堆会针对垃圾回收方式的不同来划分不同的区域，但堆存储的内容无影响（即它就为存储实例对象）。在垃圾收集时细说 Java堆的OOM异常：堆无法为实例分配内存且堆无法扩展时。 分析：此时要确立堆中的对象是否有必要存活 内存泄露：躲过GC收集 内存溢出：也就是说内存中的对象都有活着的必要（垃圾回收时详细列举） 方法区 –线程共享 方法区存储的是已被虚拟机加载的： 类信息 常量 静态变量（类变量，属于类的变量） 编译后的代码（Code中的） 内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池：用于存放编译器生成的各种字面量和符号引用。 除了保存class文件中的符号引用外，还会把翻译出来的直接引用也存储在与运行时常量池中。 并非存在于class文件中常量池中的数据才能存储在这里 运行时常量池是方法区的一部分，无法申请到内存时抛出OOM异常。 虚拟机运行数据区之外的内存区域—直接内存 堆外内存，通过堆中存储的一个引用对象来间接操作该区域。 以上就是Java虚拟机使用的内存区域分布，不同的区域完成不同的任务，同时虚拟机就会知道在哪里寻找自己想要的数据，也可以根据不同区域村存储的数据的特点来及进行不同的管理。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java容器篇]]></title>
    <url>%2F2018%2F10%2F18%2Fjava%E5%AE%B9%E5%99%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[java的容器主要有三种： map 键值对，其中键无重复 set 一种类似数学中集合的概念，要求元素无重复 数组和链表 Arraylist 动态数组类型容器 泛型容器主要方法 add get等等基本原理：内部维持着一个总有空闲的数组和实际元素的个数，期间动态修改数组大小。增加元素时整体复制。内部会记录容器的修改次数。总结：内部采用动态数组实现，按索引访问效率较高。非线性安全，增加时复制全部，删除时移动后一部分。迭代器：关注分离的思想，数据的迭代与数据的组织方式分离。在迭代过程中不可发生结构性变化（例如上面的记录修改次数，每次迭代时比较不同时刻的该值来实现检查有无结构性变化） Vector：基本原理与arraylist相同但是有使用重量级锁synchronized关键字来保证线程安全。 LinkedList：内部实现为双向链表具有三个实例变量。按需求分配空间，两端插入删除效率高，中间相对较低（因为需要比较来进行定位）。 ArrayDuque:内部实现为循环数组。内部数组保证为2的幂次方，通过位操作来判断与找到正确的位置。两端操作效率较高。 上述三种基于数组或者链表的具有顺序的容器按照内容来查找元素效率都很低，因为其需要逐个比较。 接下来是Map与set的实现类： Map接口：键值对。按照键存储与访问值。键不能重复，相同的键会覆盖原值 Set接口：表示集合中数学中集合的概念。没有定义新的方法，但是有语义约束–不能有重复元素。（后面的很多set实现类的内部都是使用的Map的键来实现元素的唯一） HashMap：根据键操作值，键值对无序。 HashMap:内部具有如下四个实例变量: 实际键值对个数的 size 阈（yu）值：size值大于此值会考虑扩展 哈希表数组 负载因子：表示下面的哈希表数组中被占用程度。 Entry类型的table（就是一个数组，叫做哈希表），Entry类型为内部定义一个类{类中有 键，值，指向下一个节点的值，键的hash值}。这个数组中的元素指向一个单向链表，链表中的每个节点表示一个键值对。 HashMap中保存键值对的过程为：123第一次保存 --(key不为空)--&gt; 计算key的hash值 --(找到table中相应的位置)|--&gt;(table中有空间)--&gt;在表头插入 |--&gt;(table中没有空间)--&gt;扩展空间---&gt;将原来的键值对移动过来并计算新的位置。 HashMap中的长度为2的幂次方。 HashMap中的查找：先找到table中的位置，然后在链表中遍历查找。 HashMap原理总结：内部有一个哈希表数组，其中元素指向一个单向链表，根据键的hash值找到链表，然后操作该链表。大量元素映射到同一个链表下时，将链表转化为平衡二叉树。 HashMap使用总结：根据键来操作值，效率较高。不是线程安全的。使用重量级锁来实现线程安全的HashTable。实现原理相同。如果要保持添加顺序则使用HashMap的子类LinkedHashMap。 LinkedHashMap：可以按照插入或者按照访问来排序。默认是按照插入来排序。HashMap的子类。 访问顺序：最开始是最求没被访问的，最末尾的是最近访问的。 使用场景： 插入排序： 需要按照输入顺序来输出，比如配置文件 希望保持添加顺序，比如购物车 输入数据本来就按照键排好序。 访问顺序： 构成LRU缓存 只有一个构造方法来使用访问排序。 内部原理：是HashMap的子类，但内部还有一个双向链表来维持键值对的顺序，也就是说同一个键值对既在哈希表中又在双向链表中。 HashSet：元素无序，无重复。 应用场景：排重，保存特殊值， 集合运算。 实现原理：内部有一个HashMap，HashMap有键值对，HashSet中只有键，值是相同的值。总结：无重复元素，高效的增删，判断存在。元素无顺序。如果要保持添加顺序，使用LinkedHashSet。 LinkedHashSet：按照添加顺序保存顺序。内部实现为LinkedHashMap。 TreeMap：键值对之间按键有序。 实现原理：内部使用红黑树实现。TreeMap具有如下实例变量： 长度 比较器 内部类型Entry： 键 值 左右孩子父节点 颜色 总结：按键有序，但要求键实现comparable接口或者comparator对象来实现比较。 TreeSet：有序，无重复。可以来排重。 实现原理：基于TreeMap来实现，键为元素，值位同一值，无重复（Map接口的要求）。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM第一步——静态存储结构class文件]]></title>
    <url>%2F2018%2F10%2F18%2FJVM%E7%AC%AC%E4%B8%80%E6%AD%A5%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84class%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[我们平时看到的运行java程序实际上经历了几次转换。 #引导 java 能成为跨平台语言得益于它增加了一层中间码—字节码。我们知道操作系统不同代表它的操作指令的不同，而编程语言是要转换成能操作机器的机器指令才能运行。 这就使得在不同操作系统上运行同样的代码，你就要重新编译成该系统能够识别的操作指令。而虚拟机的作用就是屏蔽这些差异，它会根据相同的代码调用适合该操作系统的指令。虚拟机只识别字节码，不管什么操作系统你只要给我字节码我就可以识别(当然，不同的操作系统使用的虚拟机是不同的)。正是虚拟机这种只识别一种格式的文件但能调用不同的指令实现相同的功能的特性使得java语言可以“一次编写，到处运行”。保存我们的可运行程序也就是在磁盘中保存字节码文件(.class文件)。我们知道字节码文件格式后就知道了是如何和我们编写的java代码一一对应的了。下面进入正题。 ######不容有错文件肯定是二进制字节流。class文件也是但它没有分隔符，并且它需要你按照严格的顺序排列在其中，这样它就知道哪部分是什么含义。因此无论顺序、数量，那个字节代表什么含义，长度是多少，先后顺序都是严格限定的，不容有错、有变。 #文件中的类型 class文件使用类似于C语言中的结构体的伪结构来存储数据，通篇只有两种类型： 无符号数：用来描述数字、索引引用、数量值、或者UTF-8编码的值的字符串 u1,u2,u4,u8分别代表1，2，4，8个字节 表：由无符号数或者其它表作为数据项构成描述同一类型但是数量不定的多个数据时（虚拟机不知道你到底定义了多少个），经常使用一个前置的容量计数器来告知接下来多少个是相同类型的 #魔数-咖啡宝贝class文件的前4个字节。为了确定这个文件时一个能被虚拟机接受的class文件。 #class文件版本号4字节，确定java版本 #常量池 class文件的资源仓库 class文件中第一个表类型的数据项目，常量池中的常量数目不固定，因此需要一个容量计数器。常量池可以说有如下两部分： 常量池容量计数器 各种常量数据 ##常量池计数器 能成为跨平台语言得益于它增加了一层中间码—字节码。一个u2类型的数据 从 1 开始计数（只有常量池计数器是从1开始计数，留有0是为了不引用任何常量） 每一单位记录的是一个表结构，常量池中共有14种不同的常量类型即有14种表结构。这些表结构可能会相互引用，例如代表名称的会存放字符串这种表结构的引用 ##常量数据 主要存放两大类（实际均为字符串）： 字面量 符号引用标注：这里存放符号引用实现了Java的动态连接，JVM运行时据此解析翻译成具体的内存地址。 #访问标志（u2类型）用以标识该class文件的类别和访问权限。例如：存放的是类还是接口。是public还是private。 #确认继承关系的类索引：u2类型 保存该类的全限定名。父类索引：u2类型 保存其父类的全限定名 Java不允许多重继承 因此只有一个。接口索引集合： 一组u2类型的数据集合 保存该类实现的所有接口的全限定名集合。按如上顺序排列在访问标志之后 所有保存的都是常量池中的索引 #字段表集合 描述接口或者类中声明的变量，不包括方法中声明的变量都是字段的描述信息，不会列出从超类或者父类中继承而来的字段 试着来描述一个字段 会有作用域、实例还是类变量、可变性、并发性、变量类型、变量名称等等 字段计数器 u2类型 记录字段数据的数目 下面是每个数据项都会有的内容： 字段修饰符（public等） 简单名称（对常量池的引用） 描述符（对常量池的引用）：描述符的作用是用来描述字段的数据类型【针对字段】、方法的参数列表（数量，类型，顺序）和方法的返回值【针对方法】 属性表集合用以存储额外的信息。（可有可无）static的变量会使用下面的ConstantValue来存储值（实际为字面量索引） #方法表集合和字段表集合一样是用来描述方法的有如下 访问标志 名称索引 描述符 属性表集合：方法里的Java代码经过编译器编译成字节码指令后存储在方法属性表里面的code属性中 方法表中不会存放没重写的方法 重载一个方法，除了要有相同的简单名称之外，还要求有不同的特征签名。特征签名：一个方法中各个参数在常量池中的字段符号引用的集合，返回值不再特征签名内 #属性表集合在字段表，方法表，class文件中都可以携带自己的属性表集合。限制相对宽松一点， 结构自定义，但必须含有u2类型的名称索引和长度。 Java虚拟机会忽略掉它不认识的属性 ，每个属性的名称都是从常量池中引用下面是几个常用属性： Code属性：出现在方法表中的属性集合内 属性名称 属性值长度 操作数栈深度最大值 局部变量表所需空间：局部变量表能存放的有方法的参数，catch的参数，定义的局部变量。 字节码长度： 实际有u2长度的限制，超过后编译器拒绝编译 字节码 显式异常处理表（含有四个字段）： 开始行： 结束行： 跳转行： 异常类型： 总结：如果字节码在开始行与结束行之间出现了异常类型的异常，就跳转到跳转行开始处理。编译器使用这个异常表来实现Java异常和finally处理机制。 Exceptions属性：位于方法表中。列举出方法中可能抛出的受查异常。也就是throws后列举的异常。 LineNumberTable属性：生成于class文件中。源码行号与字节码行号之间的对应关系。 LocalVariableTable属性：生成于class文件中。栈帧中的局部变量表中的变量信息。例如变量的作用域表示为：变量的开始的字节码偏移量 和 长度来表示 SourceFile属性：class文件中。记录源码文件名称。 ConstantValue属性：作用为通知虚拟机自动为变量赋值。 赋值时的情况： 1 实例变量（非static）：在实例构造器中进行赋值（init（）） 2 类变量（静态变量，属于类）赋值：在类构造器中。 ConstantValue中。 Inner class属性：记录内部类与宿主类之间的关联。 StackMapTable属性：在类加载阶段的字节码验证阶段使用。内容的意义表示执行到该字节码时局部变量表和操作数栈的验证类型 上述就是我们代码经过编译后的样子，这是我们的程序开始的第一步，下一步就是如何将程序从静态的硬盘转到动态的内存中去。结尾还有彩蛋欧~ 这里来补充一点字节码指令的相关信息。JVM指令 = 操作码（一个字节长度） + 操作数JVM采用的是面向操作数栈的 因此大多数指令不含操作数字节码与数据类型：特定的操作只提供有限的类型相关指令。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java IO使用]]></title>
    <url>%2F2018%2F09%2F07%2Fjava-IO%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[总述我们需要将数据从一端接收到另一端来使用，宏观上说我们需要的要么是一些数字啊文本啊来进行我们预期的处理，这些数据要么是存放在硬盘中（文件），要么是我们从键盘获取，但都是要交给程序来使用。这其中有两个问题： 从哪里拿（写到哪里）。&emsp;理想的就是有一个地方，我们要接收就从这个地方获取，要输送就将数据写进这个地方中，多么方便，这个地方就是流。 如何去拿（按照什么方式去写）。 &emsp;解决了 从哪里 的问题，就要说我们如何去获取，也就是按照什么方式去接收或者发送这些数据。比如说我们要按照字符串接受，或者我们要以整形的形式来接收等等。这都是我们要使用的方式。这里涉及到后面的装饰器模式。 你应该知道: 文件的读写一般需要两次数据复制,第一次是将数据从硬盘复制到 打开文件：会在操作系统的内核中建立一个内存结构，该内存结构消耗内存，因此可以同时打开的内存有限。 关闭文件：同步缓冲区内容到硬盘并释放内存结构。 流使用同一种概念来处理所有IO，屏蔽不同。换一中方式理解，流就是一个通道，里面装着数据流，从源端到接受端。数据流有字节流和字符流之分，不同就是每次读或者写的单位不同。 #####装饰器模式通过叠合多个对象来提供所期望的功能。功能可以理解成按照何种方式换句话说就是对基本的流增加功能，但是每一个增加功能的类只注重一个方面。如下： 字节流 以InputStream OutputStream 作为基类 有增加缓冲功能的： Buffered(Input / Output)Stream 规格化为按照基本类型或者String来处理：Data(Input / Output)Stream 将基本类型，对象按照字符串输出：PrintStream 字符流 以Writer Reader 作为基类 读写文件的：File(Reader/Writer) 带有缓冲的：Buffered(Reader/Writer)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令记录]]></title>
    <url>%2F2018%2F09%2F05%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[git入门命令 什么是Git，GitHub？ &nbsp;&nbsp;&nbsp;&nbsp;纯属个人理解，如有雷到，见谅见谅。。。。&nbsp;&nbsp;&nbsp;&nbsp;说的通俗一点，GitHub就是一个来存放文本文件的地方（类比网盘），它是远程服务器我们的电脑是客户端。两个地方是不是的同步一下数据来保证我们两个地方保存的东西都一样。既然如此我们就直接使用平时的网盘来保存我们的代码何必使用git或者github呢。因为它有版本控制功能，它记录了我们对文本文件的操作流水账，比如：加了哪些东西，在那些个文件中加的，在哪里做了修改等等，我们可以把不同的操作结果叫做不同的版本，每个版本有自己的版本号，我们可以在版本号列表中选择恢复到任何记录在案的版本。 刚刚下载安装git后需要设置连接用户：12git config --global user.namegit config --golbal user.email 创建版本库，即使之可以被版本管理： git init //初始化，git可管理 往简单说只需三步你就可以将本地库同步到远程：1231. git add //此命令表示将更改提交到暂存区2. git commit -m &quot;此次提交的说明性文字&quot; //表示将更改提交到仓库3. git push //此命令为省略，只是来表示为push命令，新手切勿直接使用，将本地提交到远程 到此会有疑问，什么暂存区什么仓库，如下说明：工作区：就是你在电脑上看到的目录。版本库：就是该目录下的 .git目录，在不懂的情况下不要随意改动。暂存区： 暂存区存放与版本库中，即在 .git目录中。补充：.git 中也存放着默认创建的master分支，和指向master的指针HEAD。 git status——查看有什么被修改：用来显示工作目录和暂存区的状态，不显示已经提交(git commit)到历史中的信息 git status //闲着没事就 git status 一下 你会看到有三类（个人理解）：1.Changes to be committed : 所有的都准备好了，可以被 git commit 了。2.Changes not staged for commit: 你修改过文件，需要git add一下。&ensp;&ensp;&ensp;&ensp;&ensp;就像是：喂，我知道你做过修改，过来给我报备一下，我要记录在案3.Untracked files: 表示这些文件好没有被版本库记录，如果要记录，你需要git add一下。 git add——–添加文件到暂存区git add . //添加所有文件git diff + 文件名查看该文件做了什么修改。 本人没用过，不太会。。。 *撤销更改1 知道修改了何处，手动更改回来，再add….commit2 版本回复到上一个版本 版本管理命令：1234567git log //按时间的由近到远的显示提交记录git reset -hard HEAD^ //恢复到上一个版本git reset -hard HEAD~N //恢复到上N个版本git reflog //显示每次提交的版本号（为一串数字，唯一存在） 查看你的本地仓库与远程库的关系：12git remotegit remote -vv 查看本地分支的追踪关系：1git branch -vv //查看本地分支与哪些分支存在追踪关系 创建并切换分支：git checkout -b 新分支的名字 //代表创建分支并切换到该分支该命令相当于git branch 新分支名字git checkout 新分支名字 根据远程库中的某个分支创建本地分支：git checkout -b 名称 origin/远程的分支 与分支有关的命令： 查看有哪些分支： git branch 删除分支：git branch -d 修改分支名称：git branch -m 旧 新 合并分支：git merge 分支 //将指定分支合并到当前分支，一般搭配--no-ff 参数来使用 结果是禁用fast forward还有一点就是会保存下被删除分支的版本号信息，方便来恢复 本地分支与远程分支之间存在一种追踪关系表明两者之间建立一对一的联系，或者说本地所有操作（push pull 等）针对的都是远程具有追踪关系的分支对象。git branch --set-upstream-to=远库/远分支 本地分支 clone—-克隆远程库或者远程的分支12git clone 远程库的URL //克隆远程库git clone -b 远程分支名 仓库名 本地目录 //克隆指定分支 git stash —-隐藏修改，保存现场某些情况下当前修改还未完成但是需要解决其他地方的BUG，此时可以将其隐藏起来实现不让版本器记录。123git stash list //查看被隐藏起来的工作区git stash apply 恢复 git stash drop 删除git stash pop 恢复同时删除 push——-将本地提交到远程git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 参考地址：https://www.yiibai.com/git/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习]]></title>
    <url>%2F2018%2F08%2F25%2Fmarkdown%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简单轻量级的标记语法 基本用法：单个回车表示空格 连续回车表示分段 行尾加两个空格表示段内换行 可以使用HTML标签 标题使用 #每一个#代表以及标题 最多支持6级标题 例如例如例如列表使用无序列表使用（ ，+，-） 列表使用：（ ，+，-）中选一个加一个空格例如： 列表 类表 列表 列表3 列表 有序列表数字加点号再空格 音乐 数据 #嵌套 文字格式**粗体** __粗体__ 斜体*斜体* _斜体_ 删除线链接链接语法为 [你显示的](网址) 百度 将网址放在尖括号内，即网址原样生成。例如： &lt;https://silencewmy.github.io/&gt; https://silencewmy.github.io/ 图片语法： ！[替代文本]（链接地址 &quot;&quot;） 引用 一级引用 二级引用 三级引用 目录在要生成目录的地方写 [TOC]或者[toc]，同时大写或小写。 水平分割线一串‘-’或者‘*’ 表格表头 | 表头 | 表头 :-----| -------:|:-----: 内容 | 内容 | 内容 :– 左对齐，–: 表示右对齐， :–: 居中 效果图： 表头 表头 表头 内容 内容 内容 内容 内容 内容 #文档头规范 title：文章标题 date：文章创建时间 categoties：分类 tags： 标签 toc： true or false 是否显示目录需要 top：填数字，和优先级差不多意思 description：文章摘要 comments：是否允许评论 keywords：文章关键字]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>

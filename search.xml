<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[未完成]]></title>
    <url>%2F2019%2F03%2F10%2FjavaEE%2F</url>
    <content type="text"><![CDATA[javaEE的工程一般包括 dao：dao中的类是操作一张数据库表的所有操作，关于一张表的操作都在一个类中 Javabean：就是封装数据的类 servlet：是前端与后端的交接处，一个servlet代表的是一种数据库表的操作，可以说是一个小功能吧。从前端接收到数据然后在这里实现数据处理的逻辑，如果要使用数据库中的数据，就通过使用那张表对应的dao类中的方法。 util：就提供提供数据库的连接，至于从这个连接中操作什么是dao中定义的方法。 这几个包的分层，让各种方面的逻辑代码实现分离，各种包中的类各司其职。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站应用架构的变化]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[从垂直架构（SSM），到微服务架构的变化特性总结 垂直架构： 通常基于MVC架构开发的应用代码会统一打成一个war包，部署到Tomcat等Web容器中，不同应用功能之间通过本地API进行调用，不存在跨进程的远程服务调用。 传统的MVC架构，所有业务子模块都集成在一个很重的JVM进程中。是一种垂直架构。 在高并发大流量的场景中，需要做集群，集群方案是：前端通过F5等负载均衡做七层负载均衡，后端做对等集群部署。 当业务不断发展，应用规模庞大时，垂直架构的弊端就凸显出来： 复杂应用的开发维护成本变高，部署效率逐渐降低：因为代码量变得巨大。 团队协作效率差：部分公共部分重复率太高，团队规模越大沟通和协作就更困难。 系统可靠性变差:可能引起“雪崩效应”，所有应用模块都在同一个进程中，一个节点故障就会引起整个系统的问题。 维护和定制困难：代码臃肿，无法对复杂的业务拆分，牵一发东全身 新功能上线周期变长：新上线功能无法独立部署和交付，需要和老功能一起编译打包测试 垂直应用越来越多，应用之间的交互不可避免，将核心应用抽取出来，作为独立的服务中心，公共能力抽取出来作为服务提供方，供其他调用者消费，实现服务的共享和重用。应用拆分之后按照模块独立部署，接口（可以理解为方法）调用有本地调用变为跨进程的远程方法调用，RPC框架由此产生。 RPC架构：RPC是一种进程间通信方式，允许像调用本地服务一样调用远程服务。 RPC框架原理：RPC框架的目的就是让远程服务（跨进程的调用）调用更加简单，透明，RPC框架屏蔽底层的传输方式，序列化方式和通信细节。 需要远程服务提供者提供服务调用的相关信息，远程服务的本地代理。 RPC面临的挑战： 在服务不算多的时候，只需通过PRC框架简单的暴露然后引用远程服务，通过配置服务的URL地址进行远程服务调用配上简单的硬件负载均衡即可。但是服务的数量越来越多的时候，服务的URL管理变得困难，硬件负载器的压力变大。此时需要服务注册中心来动态的注册和发现服务。通过让消费者本地缓存服务提供者列表来实现软负载。 业务的发展，服务数量增多，服务间的依赖关系变得复杂难以理清楚。此时需要分布式消息跟踪系统来展示服务调用链来梳理服务间的调用关系。 服务的调用量增大，服务合理的容量需要解决（容量就是，提供该服务的机器数量吧）。 服务上线容易，下线难，服务的生命周期需要系统的整体的管理。 在服务化之后，面临的就是服务的治理问题，单凭RPC框架无法解决服务的治理问题，必须通过服务框架+服务治理来完成。 SOA服务化架构：粗粒度松耦合的以服务为中心的架构。服务之间通过定义明确的协议和接口进行通信。 这样服务之间界限明确，就可以将应用关注与于各种组件的开发和部署，可以更迅速，可靠和可重用的规划，整个系统（从整体到局部） SOA面向服务的一般原则： 服务可复用 服务共用一个标准契约：按照服务提供者提供的使用该服务的服务契约（也就是使用方式） 服务是松耦合的：服务被设计为功能相对独立的，尽量不依赖其他服务的独立功能提供者。 服务是底层逻辑的抽象：只是暴露服务，而不是暴露服务的实现逻辑。 服务之间是可组合，可编排的，多个服务可以编排组合成新的服务 服务是自治的：服务集中于自身的逻辑，不依赖其他的服务。 服务可以自动被发现：服务上线后，允许被其他消费者自动发现，服务下线后会告知服务消费者。 SOA服务治理： 服务定义：监视服务的创建过程，描述该功能确定行为规范设计接口（SOAP）。 服务生命周期的管理： 服务版本治理 服务注册中心：如何发布，如何订阅，如何被消费者动态发现。 服务监控：对服务的运行情况进行监控。 运行期服务质量保障：在运行期动态治理，可以在不重启服务的前提下快速提升服务的运行质量。 服务安全 快速故障定界定位手段 SOA架构首要且必须要解决的就是异构服务之间的通信。为了重用已有服务，大多数异构系统仅仅是将自身服务化，并将服务发布出去，并没有使用统一的服务化框架来进行服务化，因此服务之间通信、调用需要进行协议（异构的协议）的转化，才能实现与其他服务的沟通。SOA架构不同组件服务化使用的技术和划分原则不同，SOA服务化之后的质量也良莠不齐，导致部分服务并没有体现服务化之后的价值。SOA架构解决了应用服务化的问题，随着服务化的深入，服务规模越来越大服务治理面临的挑战更多。微服务架构因此产生。 微服务架构：是一种服务化架构风格，通过将功能分散到各个离散的服务中以实现对解决方案的解耦。 微服务架构的主要特征： 原子服务，专注于一件事：功能越单一，对其他功能的依赖就越少。 高密度部署：重要的服务使用进程来跑，非核心服务独立打包到这个进程。如果云端部署可以利用LXC（Docker等）实现容器级部署 敏捷交付：服务又小团队开发 微治理：服务足够小，功能单一，可以独立打包，部署，升级，回滚，和弹性伸缩不依赖其他服务，实现局部自治 CI自动化构建帮助我们简化环境的创建、编译、打包、部署。 SOA和微服务的差异： 服务拆分的粒度：SOA关注的是异构应用的服务化，微服务强调的是将服务化的同时要求将服务拆分的尽可能小 服务依赖：SOA要复用资源，因此有大量的服务依赖。微服务强调的是服务自治，服务功能单一，避免依赖其他服务。 服务规模：SOA服务粒度较大，将多个服务整合成一个WAR包，数量有限；而微服务强调尽可能拆分，服务规模较大。 架构差异：微服务化之后，服务数量的激增会引起架构质量属性的变化。 服务治理 敏捷治理：服务有小研发团队负责，运维整个生命周期。 应用架构演进到此结束，来一个简单的总结： MVC架构（垂直架构）：业务规模较小时，所有功能部署在同一个进程中，分离前后台逻辑是关键。同过前置负载均衡器（硬件负载）实现分流。 RPC架构：当垂直应用变多，应用之间交互已成定局，通过将核心业务和公共功能抽取出来作为独立的服务，实现逻辑的分离。此时，提高业务的复用和拆分是关键。 SOA架构：业务的发展导致服务的数量增多，服务的治理成为难题，例如服务的生命周期，和运行态的治理，提升服务质量是关键。SOA服务治理。 微服务架构：通过服务的原子化拆分，微服务的独立打包、部署、升级，拆分的小服务由小团队开发缴费，应用的交付周期大大缩短。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>应用架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中间件初识]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%88%9D%E8%AF%86Java%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[什么是Java中间件，构造中间件需要哪些Java基础知识 java中间件被比喻为“软件胶水”为软件应用提供服务；起到了应用和应用之间，应用和服务之间的桥梁 ####特定的中间件是解决特定问题的组件，如下就是三个领域的中间件#### 远程过程调用和对象访问中间件：解决了分布式环境下应用的互相访问问题。 消息中间件：解决应用之间的消息的传递、解耦、异步的问题 数据访问中间件：应用访问数据库的共性问题（就是相同的功能步骤抓出来单独作为服务提供者） 消息中间件在分布式系统中完成消息收发的基础软件使用消息中间件有两个好处 异步：消息传递给消息接收者 解耦：两个应用间不直接联系 ####如何来构造Java中间件-构造Java中间件的基础知识#### JVM 垃圾回收：JVM通过内存回收机制来自动完成回收不需要动手编写，设置不同的垃圾回收方式和参数会影响垃圾回收的效果影响系统稳定性和单机的支撑能力。 内存布局以及回收方式： JVM内存堆布局 | GC方式:———–:|:—:新生代 | 串行GC Serial Copying| 并行GC ParNew |并行回收 Parallel Scavenge 年老代 | 串行GC-Serial MSC|并行GC Paraller MCS |并行 CompactingGC - Parallel Compacting |并发GC-CMS Java并发编程的类 线程池：多核时代的面向多核编程，线程池可以哦降低创建线程的开销，对线程进行回收而非销毁。每个线程都是消耗内存的 Synchronized：重量级的锁，可以声明方法或者代码块。 ReetrantLock：需要显式的用unlock来释放锁 具有try lock方法，当锁被其他持有时返回false，如果并没有被持有锁则会获得该锁，返回true。 可以设定为是否为公平锁 ReentrantReadWriteLock：读写锁，读多写少。 Volatile：禁止指令重排序，保证变量的可见性。 Atomics类：提供一些相对的原子操作。 CountDownLatch：当多个线程都到达了预期状态时触发相应事件。 CyclicBarrier：循环屏障，可以协同多个线程，让多个线程在此屏障前等待，知道所有线程都到达屏障后再一起继续执行后续动作。 Semaphone：用于管理的信号量，来控制并发的数量。执行前获取信号和执行后归还信号量来控制并发的数量。 Exchanger：类似于屏障，只有两个线程交换数据后才会继续执行后续的代码。 Future：实现方式为内部开启一个线程来等待接收远程的数据，使用的线程池中的线程。 并发容器：线程安全容器的一种，强调的时容器的并发性（加锁互斥：线程安全却降低了并发性）。并发容器的思路为：尽量不加锁。 动态代理 反射 网站严谨过程中，架构的升级，应用拆分，服务拆分，数据拆分和应用解耦需要Java中间件来完成。服务框架：对应用拆分，完成服务化。数据层：完成数据的拆分和数据的管理、扩容、和迁移等工作。消息中间件：完成应用的解耦，提供分布式环境下完成事务的思路。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM未完成]]></title>
    <url>%2F2019%2F03%2F10%2Fspring%E7%AD%89%2F</url>
    <content type="text"><![CDATA[之前采用MVC架构设计时是为了解耦各个模块，使每个模块专注于自己的逻辑，提供不同的功能分为三个部分 控制器：模型层工作内容是接受请求，根据请求调用相应的处理逻辑，就是调用模型层。 模型层：在这个部分就是实现功能的逻辑部分，接受前端的用户数据加上从数据库查询的相应数据进行数据操作最终得到结果返回给用户。可以说就是操作数据库。 视图层：就是将返回结果展示给用户看的。 对应的JavaEE文件结构就是： servlet包 dao层 jsp等 springMVC架构让结构更加松散，职责分的更细，控制器和视图层不变，将模型层拆分为业务层和数据访问层，springMVC结构如下： 控制器 业务层(service层)：操作DAO层 数据访问层(DAO层)：连接数据库 视图层 这就是宏观上的springMVC了，不同于之前JavaEE使用，我们在开发过程中自己需要在执行流程经过的每个文件中写上要跳转的下一个界面或者将数据提交到哪个逻辑处理界面，这是我们 WEB-INF/ 是资源目录, 客户端不能直接访问 springMVC配置依赖： Spring-4.3.18.RELEASE spring-framework-5.0.4.RELEASE]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java项目中的classpath指的是哪里]]></title>
    <url>%2F2019%2F03%2F10%2FJava%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84classpath%E6%8C%87%E7%9A%84%E6%98%AF%E5%93%AA%E9%87%8C%2F</url>
    <content type="text"><![CDATA[只提供一个网页链接,哈哈。。当时找了很多文章，后来看到这个最后解惑。 不仅仅是说说而已 的博客]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot 配置文件]]></title>
    <url>%2F2019%2F03%2F10%2Fspringboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[springboot配置文件的使用 ####如何使用application.properties配置文件#### 一般存在src/main/resource 将配置文件中的值绑定到需要的属性上，使用@Value(“${属性名}”)属性太多使用这种方式太繁琐，按照官方推荐，绑定到对象bean上。方式为@ConfigurationProperties(prefix = “属性的前缀”) 有时候想要将不同的配置放置在不同的配置文件中时，如何引用这些自定义的配置文件中的值在将其绑定的类前加上@PropertySource(value=”自定义配置文件的地址”)@ConfigurationProperties(prefix = “所需属性的前缀”)1234//用到test.properties中的属性值，属性以com.wmy开头@PropertySource(value="classpath:test.properties")@ConfigurationProperties(prefix = "com.wmy")@Component 配置文件的优先级：在config目录下的配置文件会覆盖在classpath文件下的配置文件。相同优先级位置放置的.yml和.properties的情况下.yml会覆盖.properties中的属性。classpath:中的配置文件属于优先级最低 针对不同环境的但是配置内容（属性）相同的配置文件的区分和使用。命名格式为：application-{profile}.properties例如：application-dev.properties application-test.properties想要选择上面两个中的某一个需要在application.properties（全局配置文件）中添加spring.profiles.active=profile（你写的名字中的一个） springboot启动类上都有一个注解@SpringBootApplication，此注解的定义包含多个注解，其中较主要的是 @Configuration（实际为@SpringBootConfiguration，但其中主要的是@Configuration） 任何标记了@Configuration的Java类定义都是一个javaconfig配置类。标记为一个SpringIOC的配置类，类中用到@Bean作用到方法上，将返回值作为一个bean注册到SpringIOC容器中，方法名字即为bean的id @CompoentScan 自动扫描并加载符合条件的组件到SpringIOC容器中，当不指定basepackages属性时，从该注解的所在类的包中扫描，springboot中就是启动类所在的包。 @EnableAutoConfiguration 借助@Import的支持，收集和注册特定场景相关的bean定义。（所有符合自动配置条件的bean） 该注解是一个复合型注解，使用了EnableAutoConfigurationImportSelector来选择所有符合条件的@Configuration类的配置。 借助spring框架原有的一个工具类SpringFactoriesLoader，可以智能的自动配置。 可以说自动配置的幕后就是SpringFactoriesLoader，它是一种扩展方案。主要功能是从META/spring.factories中来加载配置。配合@EnableAutoConfiguration使用，更多的是体现一种配置查找的功能支持。以org.springframework.boot.autoconfigure.EnableAutoConfiguration的类的全路径名作为键查找相对应的配置类。 @EnableAutoConfiguration所完成的工作就是从classpath中所有的META-INF/spring.factories配置文件搜寻org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置类（@Configuration）反射为实例类，汇总并加载到SpringIOC中。 ###spring boot的启动流程 在启动类的main方法中，运行的是SpringApplication的run（）方法，该方法首要创建一个SpringApplication实例对象，然后调用该实例对象的实例方法。 在初始化SpringApplication之前，要做一些准备工作（SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口，ApplicationContext是BeanFactory的子接口，ApplicationContext对BeanFactory做了扩展，一般使用ApplicationContext作为SpringIOC容器） 根据classpath中是否存在某个特征类来决定是否创建一个为web程序使用的ApplicationContext类型 ps：特征类为（org.springframework.web.context.ConfigurableWebApplicationContext） 使用SpringFactoriesLoader在classpath中搜索加载可用的ApplicationContextInitializer（ApplicationContext的初始化器） 同样使用SpringFactoriesLoader在classpath查找加载所有可用的ApplicationListener（监听器） 推断并设置main方法的定义类 准备工作做完后就执行run方法的逻辑了。 调用所有的SpringApplicationRunListener的started()方法（方法作用类似名字，告知开始启动springboot应用），这些运行监听器都是通过SpringFactoriesLoader查找并加载进来的 创建并配置当前SpringBoot应用将要使用的Environment。 调用所有的运行监听器的environmentPrepared()方法，告知所需环境准备完毕。 如果SpringApplication的属性showBanner设置为true，打印banner 在这一步中创建ApplicationContext，并将设置好的environment给ApplicationContext使用 根据是否设置了ApplicationContextClass类型，以及初始化准备阶段的main的推断来创建什么类型的ApplicationContext。 对ApplicationContext进一步处理。 SpringFactoriesLoader在classpath中查找的所有的ApplicationContextInitializer的initialize()方法来进一步处理 调用所有运行监听器(SpringApplicationRunListener)的ContextPrepared方法 将@EnableAutoConfiguration获取到的所有IOC配置加载到准备好了的ApplicationContext中。 调用所有的运行监听器的contextLoaded()方法,告知加载完成 调用ApplicationContext的refresh()方法，完成IOC的最后一道工序 查找当前ApplicationContext是否注册有CommandLineRunner，如有，遍历执行 调用所有的运行监听器的finished()方法，表示启动完成。 springboot中已经默认开启jpa、jdbc、mybatis的事务，当引入所对应的依赖后，事务就默认开启。springboot开启事务非常简单，只需要加一行注解。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务简单介绍]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[微服务 SOA Docker为微服务框架提供有效的容器。 单体架构好处是便于管理，所有业务代码均在一个项目中，争用一个相同的内存和CPU。单体架构的缺点： 项目过于臃肿：因为多个功能业务模块都在一个项目中 资源无法隔离：单体系统中的各个功能模块都依赖于相同的数据库与内存资源，某个功能模块对资源的使用有问题，整个系统可能会被拖垮（等待该资源的可用）。耦合度较高。 无法灵活扩展：访问量增大需要扩展时，单体架构只能进行水平扩展，也就是说扩展项目中的所有功能模块，不能有针对性的扩展某一功能部分。 解决这些问题是将单体架构系统拆分成微服务微服务是什么：个人理解就是相互独立的功能模块自成为独立的项目进行部署，该项目中只有该功能的逻辑代码，对外提供可供其他模块使用的接口，只专注于自己的功能逻辑，拥有自己的专有的数据库，进行了资源的隔离。比较专业化的说明如下简而言之，微服务架构风格是一种将单个应用程序作为一套小型服务开发的方法，每种应用程序都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。 这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。 这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。 微服务的特点如下： 独立部署，灵活扩展：微服务中的独立单位是单体架构中的单一的功能模块。这样可以有针对性的扩展某一个功能，当只有该功能遇到瓶颈。 资源的有效隔离：每一个微服务拥有独立的数据源，如果想要使用另外服务的数据库，只能调用该服务对外的接口通过该服务来获得数据。每一个微服务实例在Docker容器中运行。实现服务器资源的隔离。 团队组织架构从水平结构分成垂直架构。 微服务与面向服务架构的SOA的区别SOA架构是一种粗粒度，松耦合的服务架构。SOA强调的是异构系统之间的服务通信。是异构系统之间的通信和解耦和，屏蔽异构系统的差异，让系统可以在不同实现的机器之间能够无差错的通信。而微服务强调的是系统按照业务边界（功能之间互不影响，没有强依赖）做细粒度的拆分和部署。 可以说Dubbo很好的支持了SOA架构，Spring Cloud很好的支持了微服务架构。 有优点就有缺点，微服务的优点就会导致缺点：将原本的一个项目拆分成多个项目，增加了开发和测试的复杂度。微服务架构需要保证不同服务之间的数据一致性，因为要将按照服务拆分后的多个项目模拟成为单体架构的一个项目的运行（分布式可以说是使用多个机器来模拟出在使用一台机器，就是感觉上是在使用一台性能强悍机器） 学习文章为：[https://www.sohu.com/a/221400925_100039689]]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白的SSM框架使用]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%B0%8F%E7%99%BD%E7%9A%84SSM%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[新手使用SSM的配置和个人对SSM框架的简单理解 本文仅仅适用于被整合SSM框架搞糊涂的小白。本文单纯的告诉你怎么配置使的这三个框架结合起来。其中并没有说明每个框架怎么用。文中尽量不掺杂在开发过程中是选择注解还是XML方式的不同。因为笔者也是小白。。。 ##我们按照两个不同的顺序来介绍使用，这样可能不太会让你混乱。 ###我们先是从整体到局部首先我们要明确的是： springMVC的工作：根据不同请求调用不同的功能是springMVC完成的，是springMVC将我们的功能代码进行分离。接收前端送来的请求，调用相应的处理逻辑来处理请求，最后将结果封装（保存）到模型中传递给前端视图来展示数据。如果是你来根据不同的人来做不同的事情你肯定会：看到来了一个人-&gt;奥，是他啊-&gt;那我就怎么怎么样。springMVC也是这样来完成。 spring的工作：这里就是让你能接受spring基本功能之一的springIOC，说白了就是我们把自己有的所有的类都告诉它，然后通过spring来获取这些类的对象（这时候你有一点困惑，如果一个类需要参数也就是他需要依赖一些辅助才能完成本类的正常使用要怎么办，后面再说）。我们有了springMVC就可以完成功能逻辑的分离，想想我们的代码组成中，可以说每个类都有它的功能，我们提前编写好它，当我们用到这个功能的时候，我们就创建该类的一个对象来使用它。这种就是：我知道你有这个功能，你这个功能我要用，那我就来创建一个来使用。当通一个功能被多处使用的时候，要修改另一个类的相差无几的功能的时候，想想要怎么做，你要一个个的去修改。而spring就是帮助我们管理这些功能模块，spring中统一管理的资源（这些功能类）叫做bean。想想我们经常写的登录和注册，通过一个id来登录，发现注册表中没有这个id，就没有结果需要去注册。而找到这个id，后就返回它所需的东西，但肯定这个id是提前注册的。spring就类似这个功能。你需要往这个容器中添加东西（bean），别人通过id向容器索要该资源。你告诉容器：我要用这个类提供的功能。那么容器就会返回给你该类的一个对象，不再是你通过new来创建一个对象（当然对象肯定是要创建的，只不过不在是使用者来创建而是IOC容器来创建），这就叫做控制反转。 mybatis:这是用来操作数据库，提供sql语句，获得返回的结果。它就是连接数据库，因为对数据库的连接、操作都简单，因此通过mybatis来连接数据库。 最简单的SSM使用就是：springMVC根据前端请求来调用相对应的功能类，spring管理整个工程中的各种功能类，提供给使用者。mybatis就是执行sql语句来获得数据（将数据封装起来）供逻辑代码使用。 项目目录，后面的各种扫描的包的路径就是根据下面的目录—-本人用的IDEA12345678910111213141516171819202122232425项目名 | -.idea | -out | -resources -DB.properties -mybatis-config.xml -spring-mybatis.xml -springmvc-config.xml | -src -main -aspect -contorller -dao -POJO -service | -web -WEB-INF -css -images -jsp 以下就是将三个框架整合起来的关键性配置语句： web.xml:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 第一部分是整合spring相关的 --&gt;&lt;!-- 这是spring配置文件的路径 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt;&lt;/context-parm&gt;&lt;!-- 初始化SpringIOC是一个比较耗时的操作，而其中又是工程中要用到的所有资源的容器，因此要在使用前准备好，可以在ContextLoaderListener中实现在DispatcherServlet初始化前初始化。ContextLoaderListener是ServletContextListener的一个实现类，后者与Javaweb生命周期有关。 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 第二部分是整合SpringMVC的，配置要拦截那些东西 --&gt;&lt;!-- DispatcherServlet的定义处，DispatcherServlet本身就是一个servlet,DispatcherServlet是来初始化请求上下文的，就是根据请求转到处理器中 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc-config&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 这里是告知SpringMVC配置文件的地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-valer&gt;classpath:springmvc-config.xml&lt;/param-valer&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; &lt;!-- 这里是定义servlet拦截哪些请求，通过servlet-name来对应，这里是拦截所有的特别说一下，如果url-pattern配置的是 *.do 。 你可以理解为是一个正则，就是它只会拦截哪些请求中是以.do结尾的请求 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc-config&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springMVC配置:springmvc-config.xml123456789101112131415161718192021&lt;!-- 这里表明使用注解驱动 --&gt;&lt;mvc:annotation-drivern /&gt;&lt;!-- 配置要扫描成controller的包 --&gt;&lt;context:component-scan base-package="main.controller"&gt;&lt;!-- 配置静态资源的访问映射，下面配置中的文件将不再被前端拦截 --&gt;&lt;mvc:resources location="/WEB-INF/js/" mapping="/js/**" /&gt;&lt;mvc:resources location="/WEB-INF/css/" mapping="/css/**" /&gt;&lt;mvc:resources location="/WEB-INF/images/" mapping="/images/**" /&gt;&lt;!-- 这里是配置视图解析器，根据返回的模型来渲染到的视图的对应关系 --&gt;&lt;bean class="org.springframe.web.servelet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;!-- 上面两个属性，你配置的 prefix+你模型中给的名字+suffix 就是选择的将要渲染的视图。 --&gt;&lt;/bean&gt; spring的配置：spring-mybatis.xml 不过一般是applicationContext.xml这个名字。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- 告知配置文件在哪里 --&gt;&lt;context:property-placeholder location="classpath:DB.properties" /&gt;&lt;!-- 数据库连接池，数据源配置 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt;&lt;!-- 集成mybatis，这里是配置mybatis关键的SQLSessionFactory --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="datasource" /&gt; &lt;!-- 下面是告知mybatis的配置文件在哪里 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/bean&gt;&lt;!-- spring针对mybatis的提供事务功能的模板，也就是DataSourceTransactionManager配饰事务管理器，配置的属性只有数据源 --&gt;&lt;bean id="transactionManager" class="org.springframe.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/bean&gt;&lt;!-- 使用注解定义事务 也就是@Transcctional--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;!-- 配置成自动扫描dao，也就是mybatis中的mapper。 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 告知springIOC在哪个包中扫描dao层类 --&gt; &lt;property name="basePackage" value="main.dao" /&gt; &lt;!-- 注入用于生成session的mybatis中关键的sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 下面这条的属性叫做注解类，表示某个类只有被value中指定的注解标识后才会被扫描成 Mapper，Spring中使用的是@Repository，也就是说只要被@Repository标识后它就是一个dao层。 --&gt; &lt;property name="annotationClass" value="org.springframework.stereotype.Repository"&gt; &lt;!-- spring自动扫描的包，这个包是扫描service层 --&gt; &lt;context:component-scan base-package="main.service"/&gt; &lt;!-- XML方式启用AspectJ自动代理 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/bean&gt; mybatis配置12345678&lt;configuration&gt; &lt;!-- 设置别名，使用别名来代替复杂的完整类名，下面的是配置将这个包下的类名首 字母小写来作为springIOC中的bean的id --&gt; &lt;typeAliases&gt; &lt;package name="main.POJO"&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 经过上述的配置就可以将三个框架结合起来。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SSM框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springbootweb开发]]></title>
    <url>%2F2019%2F03%2F10%2Fspringbootweb%E5%BC%80%E5%8F%91%E4%B9%8BThymeleaf%2F</url>
    <content type="text"><![CDATA[jsp和Thymeleafweb开发 ####springboot web开发 Thymeleaf和jsp#### springboot官方并不推荐JSP技术，推荐使用的是Thymeleaf。原因如下： tomcat只支持war的打包方式，不支持可执行的jar。 Jetty嵌套的容器不支持jsp。 创建自定义的error.jsp不会覆盖错误处理的默认视图。 Thymeleaf是一款用以渲染XML/XHML/HTML5内容的模板引擎。它既可以看动态界面，又可以在没有数据的数据的时候正常查看静态的页面。 Thymeleaf可以轻易的与SpringMVC等web框架进行集成，并作为web应用的模板引擎。有如下特点 SpringMVC中的@Controller中的方法可以直接返回模板名称，Thymeleaf模板会自动进行渲染。 模板中的表达式支持spring表达式（springEL） 支持表单，兼容SpringMVC的数据绑定与验证机制 国际化支持 ####使用Thymeleaf的步骤方法#### 首先引入Thymeleaf依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 如果添加后没有添加进来就启动一下maven的clean操作，如果是idea的话在界面的右边栏MavenProjects-&gt;Plugins-&gt;clean:下面的clean:clean，选中后点击上面的绿色三角启动。编写controller值得复习的就是SpringMVC中的@Controller和@RequestMapping的使用编写HTML模板默认的模板路径为src/main/resource/templates。 如果想要将HTML的静态转换成动态视图，需要在HTML开头添加如下代码1&lt;html xmlns:th="http://www.thymeleaf.org"&gt; 此外，还需要在使用动态处理的元素前使用“th:前缀”。 ####springboot的jsp开发####添加存放jsp文件的目录在一个webapp目录用来存放jsp文件，静态资源扔放置在resources的static下。创建文件夹不能右击然后徐新建文件夹（这种方式不能创建.jsp文件）。创建方法过程如下： idea中右上角project structure（放大镜的左边按钮） 选择左边栏Modules，然后选择中间栏中的Web选项 在右下部分即Web Resource Directories中点击右边的绿色加号，然后增加webapp目录（直接写名字，如果不存在会进行创建）。 引入依赖包注意 【不能和Thymeleaf同时使用，要将Thymeleaf的依赖注释掉，不然会报错（新手问题）】jsp开发需要tomcat容器来运行，并且随使用到jstl标签。进行jsp开发要引入如下依赖包：123456789101112131415161718&lt;!--WEB支持--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--jsp页面使用jstl标签--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--用于编译jsp--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 告诉springboot视图在哪里在application.properties中配置返回文件的路径以及类型，就是要渲染的视图。12spring.mvc.view.prefix: /WEB-INF/jsp/spring.mvc.view.suffix: .jsp 如果对jsp开发任然想深入了解，移步结尾处到嘟嘟MD的博客中。 学习整理自（排名不分先后）嘟嘟MD的SpringBoot系列]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO通信]]></title>
    <url>%2F2019%2F03%2F10%2FIO%E9%80%9A%E4%BF%A1%E7%AD%89%2F</url>
    <content type="text"><![CDATA[Java异步阻塞等通信方式介绍 同步与异步：多个任务或者事件发生，其中某个事件的发生会不会导致其他事件的等待，导致整个流程不能继续执行。同步就是必须按照顺序执行，每个事件会对其他事件有影响，所以没有办法并发执行。异步：指这些事件相互之间没有影响，因此可以并发的执行。 阻塞非阻塞：当某个事件在执行过程中，所需要的某个条件没有满足，整个过程停止下来，等待这个条件满足后在往下执行，就是阻塞。而非阻塞就是在条件不满足的情况下，会得到不满足的信号，因此可以让这个执行过程感知到，这样它就可以使用CPU去做不用这个条件的是事。 阻塞IO和非阻塞IO：首先是IO操作：对数据到内存的写入和写出。IO操作的过程是（以读操作为例）：用户线程发起IO请求操作，收到后内核就会查看要读取的消息是否就绪。等到就绪后，内核将数据拷贝到用户线程（内核进行数据拷贝的过程中都会让用户线程阻塞，除了异步IO）。阻塞IO就是在数据没有就绪的时候，一直等待在那里，直到数据拷贝到所在线程。而非阻塞IO就是：在数据没有就绪的时候，内核会返回标志性信息给用户线程数据告知数据没有就绪。因此用户线程可以进行其他调度。。 同步IO和异步IO：同步IO是：一个线程请求IO操作，在该IO操作完成之前，线程会被阻塞。异步IO：IO操作不会导致线程阻塞。造成上述结果是因为要不要使用用户线程。对于同步IO，IO操作如果数据没有就绪，就需要用户线程或者内核不断轮询数据是否就绪，就绪后内核将数据拷贝到用户线程。对于异步IO来说：只有请求IO操作是由用户线程完成，轮询信息状态和拷贝数据都是有内核来完成。不会使用用户线程。因此异步IO必须要有操作系统的底层支持（内核来完成一些事情）。 五种IO模型：阻塞IO：读写数据过程中会发生阻塞现象。数据没有就绪，用户线程会阻塞交出CPU，直到数据背靠背到用户线程。 非阻塞IO：发起IO请求后会立刻得到结果，来分辨数据有无准备好。想要获得数据就需要用户线程轮询是否就绪。 多路复用IO：Java NIO就是使用的多路复用。通过一个线程来轮询所有的状态是否就绪。就绪后才开始需要这个数据的用户线程的真正的IO操作。这样只会使用一个线程的资源。轮询状态是由内核来完成的。通过轮询来检查状态的满足情况，因此，大范围满足时，导致后面事件不能及时处理。 信号驱动IO：用户发起IO请求后留下信号函数（可以理解为联系方式：其中有实际的后续的IO操作），用户线程就会离开做其他的事，数据就绪后内核通知用户线程，收到信号后，用户线程调用信号函数中的后续的IO操作函数（需要用到用户线程）。 异步IO：用户线程发起IO请求后就去做其他的事情。整个IO由内核来完成，收到请求后，立刻返回说”收到任务“，然后等待数据就绪，再将数据拷贝到用户线程。这两步做完后，内核告知用户线程IO操作完成了，数据可以直接使用了。 Reactor和Proactor模式 Reactor模式:将所有要监管的对象（统称做对象，Java 万物皆对象）进行所关注的事件进行分类，改为每类轮询自己这一类事件的对象。 Proactor模式:将IO操作交由内核来完成。检测到事件发生时，交由内核来处理，内核处理完后告知操作完成。 接下来说 Java NIO：Java NIO是面向缓冲区的。数据的读或者写都要经过缓冲区(因为缓冲区的读写是可以立刻执行完的，因此不需要等待)，使用一个线程（叫做选择器）来在多个需要IO操作的不同对象间选择哪些可以立马从缓冲区处理数据的对象。 学习自海子的博客：https://www.cnblogs.com/dolphin0520/p/3916526.html 平凡希：https://www.cnblogs.com/xiaoxi/p/6576588.html Geason崔:https://www.cnblogs.com/geason/p/5774096.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站的架构演进]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[网站如何由小变大 网站从小型的单机架构遇到瓶颈一步步升级为大型的分布式架构。 大型网站的定义：访问量和数据量，海量的数据加上非常高的并发访问量。 Java+单机 数据库和网站项目部署在同一个机器上。各个功能模块之间通过JVM内部的方法调用进行交互，他们都在同一个进程中。 访问量的增大，单机的响应变慢，单机负载较大。 –数据库和应用分离 应用服务器+数据库服务器 访问量增大，应用服务器负载告警 应用服务器的压力增大，可有针对性的进行优化。一种为 将应用从单机到集群而将一台机器变为多台机器，对于系统中要解决的问题有如下两个： 用户对多台应用服务器访问的选择问题。————-DNS或者负载均衡设备。 session问题。 什么是session（会话）？纯属个人理解！！！ 产生：使用网络服务的浏览器和服务器之间的多次交互。基于HTTP支持会话状态的机制使得web服务器可以在多次单独的请求中看到会话。如何区分请求所属于的会话（多个客户端进行服务请求）。在会话开始时服务器会分配唯一的会话标识，并通过cookie告知客户端。在客户端，要求每次进行请求需要带上会话标识。在服务器上每个会话都有独立的存储，保存不同的数据。 session问题就是当服务器由一台增加为多台时，如何保证能够找到请求所属的会话存储的数据。解决方式如下几种： session sticky：在负载均衡处做处理，根据请求所带的标识进行请求转发。这种方式和只有一台时一样，服务器只需要根据到来的请求进行处理，因为这些请求的会话数据一定在本地。一个请求对应一个服务器。缺点是当其中一台服务器出问题宕机，则该服务器上的所有的会话数据会丢失。同时在负载均衡设备上进行处理势必会造成负载的内存消耗增加。 session replication：多个服务器进行会话数据的同步。这样就能实现一条请求对应多个服务器，可以进行路由的择优选择。缺点是会造成网络带宽开销。并且每个服务器都要备份应用中全部的会话数据。 session集中存储：session数据不在服务器本地存储，而是集中存储，每个服务器根据标识或者某种算法在集中池中获得数据。 cookie Based：将session数据存储在客户端本地。通过cookie传递session数据，服务器从cookie中生成会话数据。 总结：对于大型网站来说，session集中存储和session sticky是比较好的方案。 数据读压力变大，数据读写分离 数据量访问量增加，业务大部分都读多写少。此时增加一个数据读库（读库不一定是数据库也可以是能提供读数据的各种读源）只提供读服务。面临两个问题 数据的复制（从读写库到读库）：使用数据库的复制，存在复制时延期间数据短期不一致。可以看到数据库对此的支持是有限的。因此推荐使用分布式数据访问层。 数据源的选择问题。增加的是读源，所以解决的是向读源复制数据。应用根据不同情况选择不同的数据源。写操作走主库，事务中的读操作要走主库 读源 搜索引擎： 大型网站的站内搜索功能，就是一个读库。搜索引擎的倒排表方式很大程度提高检索速度。要根据被搜索数据建立索引， 缓存 cache 加速数据库读取 分布式存储系统 数据库之外的用于存储——弥补关系型数据库的不足更多的是直接代替主库。常见的分布式存储系统有 分布式文件系统：小文件和大文件的存储问题 分布式key-value系统：高性能板结构化支持 分布式数据库：大数据和高并发的数据库系统 读写分离后又遇到瓶颈的数据库——所有数据都一个主库中造成压力瓶颈 解决方式为垂直拆分和水平拆分两种选择 垂直拆分 将数据按照业务进行划分，划分结果为同一个数据库中的数据按照业务分成了多个数据库，每个数据库有自己的连接池，并且会导致数据库事务复杂化为业务事务。解决方式为 使用分布式事务，或者去掉事务或不去追求强事务。 数据量巨大垂直拆分后又会造成瓶颈，将数据水平拆分 水平拆分就是将同一个表中的数据拆分到不同的数据库中（数量可多个） 造成水平拆分的原因是，某个业务的数据量达到单个数据库的瓶颈 水平拆分后需要解决 需要SQL路由 主键的处理不同（自增主键不可用） ####当数据库的问题解决后应用会面对问题####伴随着业务发展，应用功能会会越来越多，应用变大需考虑如何不让应用持续变大，也就是在同一个JVM进程中，所有的应用功能线程争抢同一个线程中的资源（重要的是CPU时间），代码量巨大，因此检查代码也是一个问题。解决办法如下 根据业务特性进行应用拆分例如将不同的功能进行拆分，这要求拆分后的应用之间不存在直接调用（数据如何传递）。被拆分后不同应用系统之间会存在相似的功能性代码，这就有了代码的一致和复用的问题拆分后可能连接相同的数据库。 另一种是走服务化的路线，将应用拆分成3层 web系统 来完成不同的业务功能 服务中心 提供不同的业务服务 数据库 业务的数据库服务化应用后共享的代码放在了服务中心；与数据库的交互放到了服务中心（直接降低数据库的连接数，因为由服务中心来进行数据请求）同时引入了远程的服务调用]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单机到分布式的变化]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%8D%95%E6%9C%BA%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E6%94%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[单机与分布式的区别 分布式系统的意义：组件分布在网络计算机上，组件之间仅通过消息传递来通信兵协调工作。 多进程模式：多个进程之间的内存空间是相互独立的，多进程共享数据设计到序列化和反序列化。 组成计算机的5个要素：输入设备、输出设备、运算器、控制器、存储器。将应用从单机扩展到分布式： 要素 分布式 单机 输入设备 接受其它节点信息的节点 传统的人机交互设备 输出设备 向其它节点传递消息时的节点 传统人机交互设备 控制器变化 在分布式中改为控制方式，作用为：协调或者控制节点之间的动作和行为，换句话说就是决定由谁来处理请求 单机中的控制器 运算器变化 有多个节点来组成，构成运算器的多个节点在控制器的配合下对外提供服务 单机的运算器 存储器的变化 分布式中的存储需要控制器配合使用 单机中的存储器 控制器的变化补充： 如何实现节点间的配对 硬件负载均衡：系统中的所有请求都要经过该应硬件设备，硬件负载将数据分流转发，类似于路由器的转发。 软件负载：LVS透明代理。服务的消费者和生产者只需要知道中间代理的地址就可以进行节点间的服务的使用。通过LVS透明代理，让请求方认为是中间代理完成了请求的处理。让处理方认为是中间代理进行的请求。所以请求方与处理方不需要知道彼此的地址就可以进行交流。 软件负载具有如下的缺点： 在请求的必经之路上增加了网络的开销。 因为是请求方与处理方彼此透明，通过中间代理进行交流。中间的代理就是枢纽，作用无可代替，因此需要保证无差错的运行。 使用名称服务器的直连来发现相对的节点：地址交换的作用类似于DNS服务器的发现方式。请求方将需要的服务发送给名称服务器，服务器将提供该服务的所有的服务器地址发送给请求方。 采用规则服务器发送控制路由的直连调用：方式与名称服务器类似，不同在于在接受到服务请求后，规则服务器将选择处理器的规则发送给请求方。 看到一个推荐，虽然不太明白。更多运用在有状态的场景中，例如数据或者缓存。猜测可能是根据不同的请求内容有不同的规则来进行分等级处理或者什么分区域。 任务的分配和管理：分为两个角色 master：管理任务，由master将任务分配给不同的worker进行处理 worker：任务处理。 分布式系统的难点： 缺乏全局时钟，解决为关注动作的相对次序，不在根据准确的时间。 故障独立性：指的是整个系统中的一部分存在故障问题，而其他设备正常。 单点故障：单点的定义为（某个角色或者某个功能只有一台机器在支撑）。解决方式为： 给单点做好备份，尽量降低自动恢复的时间 降低故障的影响范围 事务处理]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven学习]]></title>
    <url>%2F2018%2F11%2F25%2FMaven%2F</url>
    <content type="text"><![CDATA[maven入门 下载Maven，添加环境变量。 maven：合理叙述项目间的依赖关系。maven基于项目对象模型，通过一段描述信息来管理项目的构建。最直观的就是项目中依赖多个jar包，需要开发者一个个来下载导入，这些繁琐的步骤可以交由maven来管理。在pom.xml中根据坐标建立依赖，也就是说在pom文件中配置项目中需要的jar包，或者说需要依赖的资源 Maven中的“坐标”：用来唯一标识一个项目 groupId 所需jar包的项目名 artifactId 所需jar包的模块名 version 所需jar包的版本号 maven库：分为 本地库：mave从其他地方下载所依赖的jar包的存储地或者说mave工程中依赖的全部jar包的存储地。 第三方仓库：也称为内部中心仓库，也成为私库。一般为公司每部共享使用作为公司内部公用类库镜像的缓存，保证开发公司开发人员得到的版本都一致。 中央库：远程的有大量的常用类库，是一个资源地。maven获取jar包的过程：优先从本地仓库中查找，有私库就在私库中寻找，没有私库就从中央库中下载。 maven Java项目结构：项目 —pom.xml 核心配置，项目根下 —src –main –Java Java源码目录 –resources Java配置文件目录 –text –java 测试源码目录 –resources 测试配置目录 pom.xml中的标签 在这其中配置所需的依赖，通过坐标来定位查找所要的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt;&lt;dependencies&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM第四步——内存中的数据的如何使用]]></title>
    <url>%2F2018%2F10%2F19%2FJVM%E7%AC%AC%E4%B8%89%E6%AD%A5%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[第二步说到虚拟机的内存布局，那么虚拟机是如何将数据存放进相对应的区域的呢，这其中的过程又是什么呢。Java堆中对象的内存分配、布局和访问。 以Java程序中最多的对象的创建为例子。（其实时书中就是以此为例子^_^） 确定那一个类 遇到new指令后检查该指令的符号常量（是否被加载解析初始化），没有就先进行类的加载过程。 类加载检查后为其 分配内存（所需大小在类加载阶段完成后就可确定） 如何在堆中为对象划分内存 指针碰撞：Java堆内存是规整的，就是将分界指示器（空闲和使用过的）的指针向空闲侧移动。 空闲列表：内存不规整，维护一个可使用内存块的列表，划分是从列表中寻找一块足够使用的空间并更新空闲列表的记录。 两种划分方式取决于内存是否规整，而内存的规整取决于GC是否有压缩整理功能。 安全的在堆中为对象划分内存 JVM中对象的创建非常频繁导致并发下不是线程安全的（创建过程并非一步到位可以划分为很多步，可以被插队）。如正在为A分配空间，指针还未修改。此时对象B又使用此时的指针来分配内存。 堆分配空间的动作进行同步处理：CAS家失败重试来保证更新的原子性。一直尝试分配直到分配成功。 另一种从空间上来断绝修改相同区域的可能，不同线程给予不同的内存，不同线程在自己得到的内存中分配对象，这一块叫做本地线程分配缓冲。在线程共享的区域中分出线程私有的区域来实现线程安全的对象分配。 分配内存后，将内存区域初始化为零值。（实例字段不赋初始值是不能使用的）（不包括对象头）实例字段是通过对象去引用的。 虚拟机要对对象进行必要的设置，主要是对象头的设置。对象头如下 对象头主要分为两部分 Mark Word运行时数据（告知虚拟机如何来处理使用对象）这是额外开销与对象本身数据无关 运行时数据是一个非固定的可复用的数据结构空间，所以可以在小空间存储尽量多的内容。具体有如下 对象的哈希码：用来判断是否同一个对象，为对象的特征 GC分代年龄：通过分代年龄，虚拟机才知道如何去管理该片数据区域（后文的年龄限制进入老年区）。 指向锁的指针：锁优化中的轻量级锁，通过状态的改变来达到资源唯一使用性。 指向重量级锁的指针 偏向锁偏向的线程ID 等等都是方便虚拟机来使用对象，与对象本身所存储的数据无关。 类型指针 -确定对象属于那个类的实例的指向类元数据的指针 如果是数组对象那么对象头中有记录数组长度的数据，普通Java对象可以在类元数据中确定对象的大小。 至此在虚拟机看来对象已经生产出来了，只不过所有的变量都是零值不是程序员期望的值（init方法还未执行。），init方法执行后真正可用的对象才生产出来。 对象的内存布局 –对象在堆中到底是如何存放的针对虚拟机的不同会有不同，以HotSpot为例。对象在内存中存储的数据主要分为3部分： 对象头：在前面虚拟机对对象的设置时有介绍对象头。 实例数据 此部分存储的是真正有效的数据（程序中定义的各种字段内容） 父类继承，子类定义的都在这里 相同宽度的字段分配在一起，父类中的变量在子类之前。 对其填充 仅仅有占位符的作用，虚拟机自动内存管理系统要求地址必须是8字节的整数倍。 定位对象 –如何来访问堆中的对象 Java程序通过栈上的reference数据来操作堆上的具体对象。reference数据能做到两点 通过该引用可以访问该对象在堆中存放数据的起始地址。 通过该引用g可以对象所属的类的类型信息（在方法区，类加载机制将类加载进方法区中）。 reference只是一个指向对象的引用，并不是如何去定位、访问堆中的对象数据。 对象的访问方式取决于虚拟机实现，主流方式有如下两种： 句柄 Java堆中划分中一块区域作为句柄池，reference存储的就是对象的句柄地址。 句柄存储有： 对象的实例数据地址（堆中，对象内存布局中存储有效数据的实例数据） 类型数据（方法区中） 好处就是reference存储的一直是句柄地址，对象移动时只需改变句柄中的实例地址。 直接指针 存储的是对象的直接地址但是需要对象自己存储访问类型数据的地址（方法区中）。 好处就是速度快，一部到位。少一步指针定位（到句柄）。]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM第三步——class文件如何进入虚拟机]]></title>
    <url>%2F2018%2F10%2F18%2FJVM%E7%AC%AC%E5%9B%9B%E6%AD%A5%E2%80%94%E2%80%94class%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[class文件描述的各种信息需要加载到虚拟机才能运行和使用，将class文件转移到虚拟机中你需要知道它是如何转移，又转移到哪里。此处记录的是class文件如何进入虚拟机,class文件只有加载进虚拟机后才能使用。 ###虚拟机的类加载机制将描述类的信息的class文件加载到内存，并对数据进行校验、转换解析和初始化，形成虚拟机直接使用的Java类型。Java语言在程序运行时对类型进行加载、连接、初始化。Java语言的动态扩展特性依靠运行期动态加载和动态连接。类被加载到虚拟机内存中去和从内存中卸载出经历的生命周期为：加载、验证、准备、解析、初始化、使用、卸载这七个阶段。其中验证、准备、解析三个阶段统称为连接。加载、验证、准备、初始化和卸载必须有这种相对顺序，解析阶段可以在初始化之后再开始。 ####何时开始加载阶段呢？或者说何时进行初始化阶段 简单说就是使用时必须要初始化Java虚拟机并无规定何时开始加载阶段，但是严格规定如下5种（有且仅有）情况必须立即进行“初始化”阶段。按照严格的相对顺序，此时必须完成加载、验证、准备这三个阶段。 new（实例化对象的时候）、putstatic+getstatic(设置类的静态字段)、invokestatic（调用静态方法时），如未曾初始化该类需要先初始化。 对类进行反射调用，但该类没有进行初始化。 初始化类时发现其父类并未初始化 首先初始化用户在虚拟机启动时指定的主类。 动态使用的类未曾初始化。 ###类加载的全过程如下 ####加载阶段 –给JVM提供“原材料”要完成如下三件事情： 通过类的全限名获取该类的二进制字节流（可以理解为class文件，但是不止class文件） class文件 jsp应用等其他文件生成 从网络中获取 将字节流中的静态存储结构转换成方法区的运行时数据结构 生成代表该类的引用（Class类型的对象），这是这个类在方法区所有数据的访问入口。 class类型的对象虽然是对象，但是却存在于方法区中。 加载阶段的开发人员可控性强，可以自定义类加载器（可以控制字节流的获取方式）。类和该类的类加载器一起确定唯一性 类加载阶段完成后，JVM外部的二进制流就按照格式存储在方法区中了。 ####验证阶段 –自我保护的手段 验证阶段的主要目的：确保字节流文件中包含的信息符合JVM的要求，如果不符合规范要求则抛出异常 因为class文件不全是Java源码文件编译出来。如果不检查合法性会因有害的字节流导致系统崩溃。 具有大量约束和验证规则的规范 验证阶段完成下面4个动作： 文件格式验证 –验查索引处是否有正确值，是否符合编码要求 验证字节（检验的对象是二进制字节流）流是否符合class文件的格式规范。通过该检验后字节流才能进入方法区。 主要目的是确保输入的字节流能正确的解析 魔数 版本号 指向常量池的索引值是否都有了正确的常量 后面的三个验证阶段都欧式基于方法区，只有文件格式验证是基于二进制字节流 元数据验证 –元数据的数据类型校验 对类的元数据进行语义校验 检查是否有父类，是否继承了不允许被继承的类 字节码验证 –对类的方法进行校验 主要目的是确定程序语义是合法的、符合逻辑的 操作栈中的与指令的对应 跳转指令不会跳到错误的地方 为节省时间将验证阶段的“推导状态的动作提前”，在编译阶段将方法的本地变量表和操作栈的状态存储进StackMapTable中，验证时只需检验该属性的合法性即可。 符号引用验证 –保证解析动作能够正常执行 在将符号引用转换成直接引用的时候进行验证 就是对常量池中的符号引用进行匹配性校验，保证都能找到且找到的都是正确的。 验证符号引用的访问权限（是否可以被当前类访问）。 准备阶段 -正式为类变量分配内存区域并设置初始值 是在方法区中为类变量（被static修饰的变量）分配区域，并设置初始值 实例变量会随对象实例化时分配在Java堆中 如若字段属性中有ConstantValue存在，则会为static变量设置值。 解析阶段 -将符号引用替换为直接应用的阶段 符号引用 一组符号（可以说是字符串）用来唯一描述所引用过的目标 所引用的目标不一定是已经加载到内存中 直接引用 与虚拟机的内存分布相关 所引用的目标的实际存储地址 指向目标的指针 能间接定位目标的句柄 或者能定位到目标的偏移量 没有规定解析阶段的具体时间，表示在执行（操作符号引用的）指令之前对符号引用进行解析。 对符号引用的解析可能会有多次，除动态调用外，解析结果可缓存。 解析阶段主要对7种符号引用进行解析 类或者接口 将不是数组类型的类的符号引用交给使用它的类的类加载器（即两个类使用同一个类加载器） 数组类型的的每个元素按照上面的方式解析，最后由虚拟机生成数组对象。 解析完成前进行符号引用验证，验证是否具有访问权限。无访问权限抛出异常。 字段解析 首先要求就是对该字段所属类的符号引用已经被解析。 按照从该类、（继承关系的从下往上）接口、父类搜索该字段相同简单名称和描述符的字段 上述都搜索不到时抛出错误 如若该字段同时出现在自己父类或者接口中时，编译器拒绝编译并抛出异常。 类方法解析 首先确保该类方法所属的类已经被解析 按照该类、父类、（递归的从下到上的搜索）接口 找到返回直接引用，没找到抛出异常。 接口方法解析 同样要确保所属类或接口的符号引用被解析 判断该引用是否为接口，如若不是则抛出异常 在其父接口中递归查找 方法类型 方法句柄 调用点限定符 初始化阶段 -真正执行类中定义的Java程序代码 按照程序员意愿去初始化类变量（准备阶段时设置初始值并不是程序员赋予的值）和其他资源。 可以说初始化阶段就是执行类构造器方法(clinit)的过程 clinit方法的形成： 编译器自动收集类中的类变量的赋值动作和静态语句块中的语句合并而成，按照出现顺序。 以上就是将class文件加载进虚拟机的过程也可以说时将class字节流从固态存储地移动到动态内存来给虚拟机使用的过程。在这个过程中可以看到虚拟机是如何将二进制字节流转移到内存中去的，经历了哪些必要的处理才最后存储进我们第二步的存储区中。]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM第二步————class文件在虚拟机中的目的地]]></title>
    <url>%2F2018%2F10%2F18%2FJVM%E7%AC%AC%E4%BA%8C%E6%AD%A5%E2%80%94%E2%80%94class%E6%96%87%E4%BB%B6%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[class文件描述的各种信息需要加载到虚拟机才能运行和使用，将class文件转移到虚拟机中你需要知道它是如何转移，又转移到哪里。此处说明转移到哪里 Java虚拟机将从系统得到的内存划分为不同区域来完成不同的用途，虚拟机采用自动内存管理机制使得我们不用为我们使用的class文件来分配空间，不同的数据区域有着不同的创建和销毁时间。 ###虚拟机的运行时数据区域这是主要的class文件进入虚拟机要存放的地方，它有如下几个区域： 程序计数器 虚拟机栈 本地方法栈 方法区 堆 ####程序计数器 –线程私有使用的空间较小，是字节码行号指示器来选区下一条指令。每个线程都有自己独立的程序计数器来保证多线程可以顺利的执行（切换到正确的执行位置）。唯一一个不涉及OOM情况的区域 ####虚拟机栈 –线程私有描述的是Java方法执行的内存模型，也就是方法整个执行过程都在这里。每一个方法的内容总会有数据的操作，这一区域实现的就是把所有这个方法要使用的数据保存进来然后进行想要的处理得出结果的过程。每一个栈帧对应一个方法，每个方法从调用到执行完成的过程对应着一个栈帧在虚拟机栈中的入栈和出栈。那么栈帧是什么呢。。 #####栈帧 –一种数据结构，用来支持方法的调用和方法的执行，方法运行时所有的信息。在编译程序代码的时候，栈帧需要多大的局部变量表，多深的操作栈都已经确定好了，在方法表的Code属性中，因此一个栈帧需要多大的内存已经确定，不会受到运行期数据的影响。线程中的方法调用链很长，有多个方法处于执行状态（就是入栈了），但只有位于栈顶的栈帧才有效栈帧包括这几个部分： 局部变量表 用来存储方法局部变量和方法参数的一组存储空间。 以变量槽作为单位（slot），64位用连续的两个slot 通过索引定位的方式来使用局部变量表，索引范围从0到最大容量数（Code属性中） 虚拟机是使用局部变量表来完成参数值到参数列表的传递 局部变量中的存储空间是可以被重用的（针对的是方法体中定义的变量） 局部变量的存储也是有顺序的，按照如下顺序来存放： 方法所属的对象的引用，也就是this 存放在索引0处 然后是方法表的参数表中的参数顺序 而后是方法体中定义的变量顺序和作用域来分配 除存储基本数据类型外，存储一个reference类型来表示对象的实例引用作用： 通过该引用可以直接或者间接的查找到该对象在堆中的数据存放的起始地址 直接或者间接的查找到对象对应的在方法区中的类型信息 局部变量定义后不赋初始值是不能使用的 操作数栈 最大深度在编译期写在方法表中的Code属性中 在方法执行过程中操作栈深度不会超过上面的最大深度 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，因为Java字节码指令是面向操作栈的，指令中会限制要操作的数据的类型。 针对操作栈的优化：两个栈帧出现部分重叠（下面栈帧的部分操作数栈与上面的部分局部变量表重叠），在方法调用的过程中公用一些数据来减少参数的复制。 动态连接 每个栈帧（方法，因为一个栈帧代表一个方法）指向运行时常量池的引用，也就是所属方法的引用。 动态连接是什么：class文件中的符号引用在每一次的运行期间转换为直接引用称为动态连接 方法返回地址 方法的两种退出方式 正常完成出口：遇到任意方法返回指令，返回给调用者。 异常完成出口：方法遇到的异常没有匹配到异常处理器（class文件中Code属性中的异常处理表和方法表中的Exceptions属性所罗列的异常），此种方式不会给上层调用者产生任何返回值。 虚拟机栈会抛出的异常： 线程请求栈深度大于虚拟机栈允许的最大深度抛出 StackOverflowError异常 虚拟机栈在动态扩展时无法申请到足够的内存就会抛出 OOMError异常 本地方法栈 –类似栈而服务不同对象虚拟机栈为执行Java方法服务，本地方法栈为执行非Java方法（Native方法）服务。抛出的异常也和虚拟机栈一般。 Java堆 –所有线程共享的一块区域，在虚拟机启动时创建 new即会在堆上分配内存 唯一目的：存放对象实例。 虚拟机规范中“所有的对象实例和数组都要在堆上分配”。 垃圾收集器管理的主要区域。 堆会针对垃圾回收方式的不同来划分不同的区域，但堆存储的内容无影响（即它就为存储实例对象）。在垃圾收集时细说 Java堆的OOM异常：堆无法为实例分配内存且堆无法扩展时。 分析：此时要确立堆中的对象是否有必要存活 内存泄露：躲过GC收集 内存溢出：也就是说内存中的对象都有活着的必要（垃圾回收时详细列举） 方法区 –线程共享 方法区存储的是已被虚拟机加载的： 类信息 常量 静态变量（类变量，属于类的变量） 编译后的代码（Code中的） 内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池：用于存放编译器生成的各种字面量和符号引用。 除了保存class文件中的符号引用外，还会把翻译出来的直接引用也存储在与运行时常量池中。 并非存在于class文件中常量池中的数据才能存储在这里 运行时常量池是方法区的一部分，无法申请到内存时抛出OOM异常。 虚拟机运行数据区之外的内存区域—直接内存 堆外内存，通过堆中存储的一个引用对象来间接操作该区域。 以上就是Java虚拟机使用的内存区域分布，不同的区域完成不同的任务，同时虚拟机就会知道在哪里寻找自己想要的数据，也可以根据不同区域村存储的数据的特点来及进行不同的管理。我们将编写的class文件从静态存储地转移到动态的内存中的存储布局，这些都是一一对应的。]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java容器篇]]></title>
    <url>%2F2018%2F10%2F18%2Fjava%E5%AE%B9%E5%99%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[java的容器主要有三种： map 键值对，其中键无重复 set 一种类似数学中集合的概念，要求元素无重复 数组和链表 Arraylist 动态数组类型容器 泛型容器主要方法 add get等等基本原理：内部维持着一个总有空闲的数组和实际元素的个数，期间动态修改数组大小。增加元素时整体复制。内部会记录容器的修改次数。总结：内部采用动态数组实现，按索引访问效率较高。非线性安全，增加时复制全部，删除时移动后一部分。迭代器：关注分离的思想，数据的迭代与数据的组织方式分离。在迭代过程中不可发生结构性变化（例如上面的记录修改次数，每次迭代时比较不同时刻的该值来实现检查有无结构性变化） Vector：基本原理与arraylist相同但是有使用重量级锁synchronized关键字来保证线程安全。 LinkedList：内部实现为双向链表具有三个实例变量。按需求分配空间，两端插入删除效率高，中间相对较低（因为需要比较来进行定位）。 ArrayDuque:内部实现为循环数组。内部数组保证为2的幂次方，通过位操作来判断与找到正确的位置。两端操作效率较高。 上述三种基于数组或者链表的具有顺序的容器按照内容来查找元素效率都很低，因为其需要逐个比较。 接下来是Map与set的实现类： Map接口：键值对。按照键存储与访问值。键不能重复，相同的键会覆盖原值 Set接口：表示集合中数学中集合的概念。没有定义新的方法，但是有语义约束–不能有重复元素。（后面的很多set实现类的内部都是使用的Map的键来实现元素的唯一） HashMap：根据键操作值，键值对无序。 HashMap:内部具有如下四个实例变量: 实际键值对个数的 size 阈（yu）值：size值大于此值会考虑扩展 哈希表数组 负载因子：表示下面的哈希表数组中被占用程度。 Entry类型的table（就是一个数组，叫做哈希表），Entry类型为内部定义一个类{类中有 键，值，指向下一个节点的值，键的hash值}。这个数组中的元素指向一个单向链表，链表中的每个节点表示一个键值对。 HashMap中保存键值对的过程为：123第一次保存 --(key不为空)--&gt; 计算key的hash值 --(找到table中相应的位置)|--&gt;(table中有空间)--&gt;在表头插入 |--&gt;(table中没有空间)--&gt;扩展空间---&gt;将原来的键值对移动过来并计算新的位置。 HashMap中的长度为2的幂次方。 HashMap中的查找：先找到table中的位置，然后在链表中遍历查找。 HashMap原理总结：内部有一个哈希表数组，其中元素指向一个单向链表，根据键的hash值找到链表，然后操作该链表。大量元素映射到同一个链表下时，将链表转化为平衡二叉树。 HashMap使用总结：根据键来操作值，效率较高。不是线程安全的。使用重量级锁来实现线程安全的HashTable。实现原理相同。如果要保持添加顺序则使用HashMap的子类LinkedHashMap。 LinkedHashMap：可以按照插入或者按照访问来排序。默认是按照插入来排序。HashMap的子类。 访问顺序：最开始是最求没被访问的，最末尾的是最近访问的。 使用场景： 插入排序： 需要按照输入顺序来输出，比如配置文件 希望保持添加顺序，比如购物车 输入数据本来就按照键排好序。 访问顺序： 构成LRU缓存 只有一个构造方法来使用访问排序。 内部原理：是HashMap的子类，但内部还有一个双向链表来维持键值对的顺序，也就是说同一个键值对既在哈希表中又在双向链表中。 HashSet：元素无序，无重复。 应用场景：排重，保存特殊值， 集合运算。 实现原理：内部有一个HashMap，HashMap有键值对，HashSet中只有键，值是相同的值。总结：无重复元素，高效的增删，判断存在。元素无顺序。如果要保持添加顺序，使用LinkedHashSet。 LinkedHashSet：按照添加顺序保存顺序。内部实现为LinkedHashMap。 TreeMap：键值对之间按键有序。 实现原理：内部使用红黑树实现。TreeMap具有如下实例变量： 长度 比较器 内部类型Entry： 键 值 左右孩子父节点 颜色 总结：按键有序，但要求键实现comparable接口或者comparator对象来实现比较。 TreeSet：有序，无重复。可以来排重。 实现原理：基于TreeMap来实现，键为元素，值位同一值，无重复（Map接口的要求）。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM第一步——静态存储结构class文件]]></title>
    <url>%2F2018%2F10%2F18%2FJVM%E7%AC%AC%E4%B8%80%E6%AD%A5%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84class%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[我们平时看到的运行java程序实际上经历了几次转换。 #引导# java 能成为跨平台语言得益于它增加了一层中间码—字节码。我们知道操作系统不同代表它的操作指令的不同，而编程语言是要转换成能操作机器的机器指令才能运行。 这就使得在不同操作系统上运行同样的代码，你就要重新编译成该系统能够识别的操作指令。而虚拟机的作用就是屏蔽这些差异，它会根据相同的代码调用适合该操作系统的指令。虚拟机只识别字节码，不管什么操作系统你只要给我字节码我就可以识别(当然，不同的操作系统使用的虚拟机是不同的)。正是虚拟机这种只识别一种格式的文件但能调用不同的指令实现相同的功能的特性使得java语言可以“一次编写，到处运行”。保存我们的可运行程序也就是在磁盘中保存字节码文件(.class文件)。我们知道字节码文件格式后就知道了是如何和我们编写的java代码一一对应的了。下面进入正题。 ######不容有错######文件肯定是二进制字节流。class文件也是但它没有分隔符，并且它需要你按照严格的顺序排列在其中，这样它就知道哪部分是什么含义。因此无论顺序、数量，那个字节代表什么含义，长度是多少，先后顺序都是严格限定的，不容有错、有变。 #文件中的类型# class文件使用类似于C语言中的结构体的伪结构来存储数据，通篇只有两种类型： 无符号数：用来描述数字、索引引用、数量值、或者UTF-8编码的值的字符串 u1,u2,u4,u8分别代表1，2，4，8个字节 表：由无符号数或者其它表作为数据项构成描述同一类型但是数量不定的多个数据时（虚拟机不知道你到底定义了多少个），经常使用一个前置的容量计数器来告知接下来多少个是相同类型的 #魔数-咖啡宝贝#class文件的前4个字节。为了确定这个文件时一个能被虚拟机接受的class文件。 #class文件版本号#4字节，确定java版本 #常量池 class文件的资源仓库# class文件中第一个表类型的数据项目，常量池中的常量数目不固定，因此需要一个容量计数器。常量池可以说有如下两部分： 常量池容量计数器 各种常量数据 ##常量池计数器## 能成为跨平台语言得益于它增加了一层中间码—字节码。一个u2类型的数据 从 1 开始计数（只有常量池计数器是从1开始计数，留有0是为了不引用任何常量） 每一单位记录的是一个表结构，常量池中共有14种不同的常量类型即有14种表结构。这些表结构可能会相互引用，例如代表名称的会存放字符串这种表结构的引用 ##常量数据## 主要存放两大类（实际均为字符串）： 字面量 符号引用标注：这里存放符号引用实现了Java的动态连接，JVM运行时据此解析翻译成具体的内存地址。 #访问标志（u2类型）#用以标识该class文件的类别和访问权限。例如：存放的是类还是接口。是public还是private。 #确认继承关系的#类索引：u2类型 保存该类的全限定名。父类索引：u2类型 保存其父类的全限定名 Java不允许多重继承 因此只有一个。接口索引集合： 一组u2类型的数据集合 保存该类实现的所有接口的全限定名集合。按如上顺序排列在访问标志之后 所有保存的都是常量池中的索引 #字段表集合 描述接口或者类中声明的变量，不包括方法中声明的变量#都是字段的描述信息，不会列出从超类或者父类中继承而来的字段 试着来描述一个字段 会有作用域、实例还是类变量、可变性、并发性、变量类型、变量名称等等 字段计数器 u2类型 记录字段数据的数目 下面是每个数据项都会有的内容： 字段修饰符（public等） 简单名称（对常量池的引用） 描述符（对常量池的引用）：描述符的作用是用来描述字段的数据类型【针对字段】、方法的参数列表（数量，类型，顺序）和方法的返回值【针对方法】 属性表集合用以存储额外的信息。（可有可无）static的变量会使用下面的ConstantValue来存储值（实际为字面量索引） #方法表集合#和字段表集合一样是用来描述方法的有如下 访问标志 名称索引 描述符 属性表集合：方法里的Java代码经过编译器编译成字节码指令后存储在方法属性表里面的code属性中 方法表中不会存放没重写的方法 重载一个方法，除了要有相同的简单名称之外，还要求有不同的特征签名。特征签名：一个方法中各个参数在常量池中的字段符号引用的集合，返回值不再特征签名内 #属性表集合#在字段表，方法表，class文件中都可以携带自己的属性表集合。限制相对宽松一点， 结构自定义，但必须含有u2类型的名称索引和长度。 Java虚拟机会忽略掉它不认识的属性 ，每个属性的名称都是从常量池中引用下面是几个常用属性： Code属性：出现在方法表中的属性集合内 属性名称 属性值长度 操作数栈深度最大值 局部变量表所需空间：局部变量表能存放的有方法的参数，catch的参数，定义的局部变量。 字节码长度： 实际有u2长度的限制，超过后编译器拒绝编译 字节码 显式异常处理表（含有四个字段）： 开始行： 结束行： 跳转行： 异常类型： 总结：如果字节码在开始行与结束行之间出现了异常类型的异常，就跳转到跳转行开始处理。编译器使用这个异常表来实现Java异常和finally处理机制。 Exceptions属性：位于方法表中。列举出方法中可能抛出的受查异常。也就是throws后列举的异常。 LineNumberTable属性：生成于class文件中。源码行号与字节码行号之间的对应关系。 LocalVariableTable属性：生成于class文件中。栈帧中的局部变量表中的变量信息。例如变量的作用域表示为：变量的开始的字节码偏移量 和 长度来表示 SourceFile属性：class文件中。记录源码文件名称。 ConstantValue属性：作用为通知虚拟机自动为变量赋值。 赋值时的情况： 1 实例变量（非static）：在实例构造器中进行赋值（init（）） 2 类变量（静态变量，属于类）赋值：在类构造器中。 ConstantValue中。 Inner class属性：记录内部类与宿主类之间的关联。 StackMapTable属性：在类加载阶段的字节码验证阶段使用。内容的意义表示执行到该字节码时局部变量表和操作数栈的验证类型 上述就是我们代码经过编译后的样子（就是我们写好程序后编译成class文件存储的样子，它是按照上述的格式存储在磁盘上），这是我们的程序开始的第一步，下一步就是如何将程序从静态的硬盘转到动态的内存中去。结尾还有彩蛋欧~ 这里来补充一点字节码指令的相关信息。JVM指令 = 操作码（一个字节长度） + 操作数JVM采用的是面向操作数栈的 因此大多数指令不含操作数字节码与数据类型：特定的操作只提供有限的类型相关指令。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java IO使用]]></title>
    <url>%2F2018%2F09%2F07%2Fjava-IO%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[总述我们需要将数据从一端接收到另一端来使用，宏观上说我们需要的要么是一些数字啊文本啊来进行我们预期的处理，这些数据要么是存放在硬盘中（文件），要么是我们从键盘获取，但都是要交给程序来使用。这其中有两个问题： 从哪里拿（写到哪里）。&emsp;理想的就是有一个地方，我们要接收就从这个地方获取，要输送就将数据写进这个地方中，多么方便，这个地方就是流。 如何去拿（按照什么方式去写）。 &emsp;解决了 从哪里 的问题，就要说我们如何去获取，也就是按照什么方式去接收或者发送这些数据。比如说我们要按照字符串接受，或者我们要以整形的形式来接收等等。这都是我们要使用的方式。这里涉及到后面的装饰器模式。 你应该知道: 文件的读写一般需要两次数据复制,第一次是将数据从硬盘复制到 打开文件：会在操作系统的内核中建立一个内存结构，该内存结构消耗内存，因此可以同时打开的内存有限。 关闭文件：同步缓冲区内容到硬盘并释放内存结构。 流使用同一种概念来处理所有IO，屏蔽不同。换一中方式理解，流就是一个通道，里面装着数据流，从源端到接受端。数据流有字节流和字符流之分，不同就是每次读或者写的单位不同。 #####装饰器模式通过叠合多个对象来提供所期望的功能。功能可以理解成按照何种方式换句话说就是对基本的流增加功能，但是每一个增加功能的类只注重一个方面。如下： 字节流 以InputStream OutputStream 作为基类 有增加缓冲功能的： Buffered(Input / Output)Stream 规格化为按照基本类型或者String来处理：Data(Input / Output)Stream 将基本类型，对象按照字符串输出：PrintStream 字符流 以Writer Reader 作为基类 读写文件的：File(Reader/Writer) 带有缓冲的：Buffered(Reader/Writer)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令记录]]></title>
    <url>%2F2018%2F09%2F05%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[git入门命令 什么是Git，GitHub？ &nbsp;&nbsp;&nbsp;&nbsp;纯属个人理解，如有雷到，见谅见谅。。。。&nbsp;&nbsp;&nbsp;&nbsp;说的通俗一点，GitHub就是一个来存放文本文件的地方（类比网盘），它是远程服务器我们的电脑是客户端。两个地方是不是的同步一下数据来保证我们两个地方保存的东西都一样。既然如此我们就直接使用平时的网盘来保存我们的代码何必使用git或者github呢。因为它有版本控制功能，它记录了我们对文本文件的操作流水账，比如：加了哪些东西，在那些个文件中加的，在哪里做了修改等等，我们可以把不同的操作结果叫做不同的版本，每个版本有自己的版本号，我们可以在版本号列表中选择恢复到任何记录在案的版本。 刚刚下载安装git后需要设置连接用户：12git config --global user.namegit config --golbal user.email 创建版本库，即使之可以被版本管理： git init //初始化，git可管理 往简单说只需三步你就可以将本地库同步到远程：1231. git add //此命令表示将更改提交到暂存区2. git commit -m &quot;此次提交的说明性文字&quot; //表示将更改提交到仓库3. git push //此命令为省略，只是来表示为push命令，新手切勿直接使用，将本地提交到远程 到此会有疑问，什么暂存区什么仓库，如下说明：工作区：就是你在电脑上看到的目录。版本库：就是该目录下的 .git目录，在不懂的情况下不要随意改动。暂存区： 暂存区存放与版本库中，即在 .git目录中。补充：.git 中也存放着默认创建的master分支，和指向master的指针HEAD。 git status——查看有什么被修改：用来显示工作目录和暂存区的状态，不显示已经提交(git commit)到历史中的信息 git status //闲着没事就 git status 一下 你会看到有三类（个人理解）：1.Changes to be committed : 所有的都准备好了，可以被 git commit 了。2.Changes not staged for commit: 你修改过文件，需要git add一下。&ensp;&ensp;&ensp;&ensp;&ensp;就像是：喂，我知道你做过修改，过来给我报备一下，我要记录在案3.Untracked files: 表示这些文件好没有被版本库记录，如果要记录，你需要git add一下。 git add——–添加文件到暂存区git add . //添加所有文件git diff + 文件名查看该文件做了什么修改。 本人没用过，不太会。。。 *撤销更改1 知道修改了何处，手动更改回来，再add….commit2 版本回复到上一个版本 版本管理命令：1234567git log //按时间的由近到远的显示提交记录git reset -hard HEAD^ //恢复到上一个版本git reset -hard HEAD~N //恢复到上N个版本git reflog //显示每次提交的版本号（为一串数字，唯一存在） 查看你的本地仓库与远程库的关系：12git remotegit remote -vv 查看本地分支的追踪关系：1git branch -vv //查看本地分支与哪些分支存在追踪关系 创建并切换分支：git checkout -b 新分支的名字 //代表创建分支并切换到该分支该命令相当于git branch 新分支名字git checkout 新分支名字 根据远程库中的某个分支创建本地分支：git checkout -b 名称 origin/远程的分支 与分支有关的命令： 查看有哪些分支： git branch 删除分支：git branch -d 修改分支名称：git branch -m 旧 新 合并分支：git merge 分支 //将指定分支合并到当前分支，一般搭配--no-ff 参数来使用 结果是禁用fast forward还有一点就是会保存下被删除分支的版本号信息，方便来恢复 本地分支与远程分支之间存在一种追踪关系表明两者之间建立一对一的联系，或者说本地所有操作（push pull 等）针对的都是远程具有追踪关系的分支对象。git branch --set-upstream-to=远库/远分支 本地分支 clone—-克隆远程库或者远程的分支12git clone 远程库的URL //克隆远程库git clone -b 远程分支名 仓库名 本地目录 //克隆指定分支 git stash —-隐藏修改，保存现场某些情况下当前修改还未完成但是需要解决其他地方的BUG，此时可以将其隐藏起来实现不让版本器记录。123git stash list //查看被隐藏起来的工作区git stash apply 恢复 git stash drop 删除git stash pop 恢复同时删除 push——-将本地提交到远程git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 参考地址：https://www.yiibai.com/git/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习]]></title>
    <url>%2F2018%2F08%2F25%2Fmarkdown%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简单轻量级的标记语法 基本用法：单个回车表示空格 连续回车表示分段 行尾加两个空格表示段内换行 可以使用HTML标签 标题使用 #每一个#代表以及标题 最多支持6级标题 例如例如例如列表使用无序列表使用（ ，+，-） 列表使用：（ ，+，-）中选一个加一个空格例如： 列表 类表 列表 列表3 列表 有序列表数字加点号再空格 音乐 数据 #嵌套 文字格式**粗体** __粗体__ 斜体*斜体* _斜体_ 删除线链接链接语法为 [你显示的](网址) 百度 将网址放在尖括号内，即网址原样生成。例如： &lt;https://silencewmy.github.io/&gt; https://silencewmy.github.io/ 图片语法： ！[替代文本]（链接地址 &quot;&quot;） 引用 一级引用 二级引用 三级引用 目录在要生成目录的地方写 [TOC]或者[toc]，同时大写或小写。 水平分割线一串‘-’或者‘*’ 表格表头 | 表头 | 表头 :-----| -------:|:-----: 内容 | 内容 | 内容 :– 左对齐，–: 表示右对齐， :–: 居中 效果图： 表头 表头 表头 内容 内容 内容 内容 内容 内容 #文档头规范 title：文章标题 date：文章创建时间 categoties：分类 tags： 标签 toc： true or false 是否显示目录需要 top：填数字，和优先级差不多意思 description：文章摘要 comments：是否允许评论 keywords：文章关键字]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>

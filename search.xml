<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM第一步——静态存储结构]]></title>
    <url>%2F2018%2F10%2F18%2FJVM%E7%AC%AC%E4%B8%80%E6%AD%A5%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[我们平时看到的运行java程序实际上经历了几次转换。 #引导java 能成为跨平台语言得益于它增加了一层中间码—字节码。我们知道操作系统不同代表它的操作指令的不同，而编程语言是要转换成能操作机器的机器指令才能运行。 这就使得在不同操作系统上运行同样的代码，你就要重新编译成该系统能够识别的操作指令。而虚拟机的作用就是屏蔽这些差异，它会根据相同的代码调用适合该操作系统的指令。虚拟机只识别字节码，不管什么操作系统你只要给我字节码我就可以识别(当然，不同的操作系统使用的虚拟机是不同的)。正是虚拟机这种只识别一种格式的文件但能调用不同的指令实现相同的功能的特性使得java语言可以“一次编写，到处运行”。保存我们的可运行程序也就是在磁盘中保存字节码文件(.class文件)。我们知道字节码文件格式后就知道了是如何和我们编写的java代码一一对应的了。下面进入正题。 ######不容有错文件肯定是二进制字节流。class文件也是但它没有分隔符，并且它需要你按照严格的顺序排列在其中，这样它就知道哪部分是什么含义。因此无论顺序、数量，那个字节代表什么含义，长度是多少，先后顺序都是严格限定的，不容有错、有变。 #文件中的类型class文件使用类似于C语言中的结构体的伪结构来存储数据，通篇只有两种类型： 无符号数：用来描述数字、索引引用、数量值、或者UTF-8编码的值的字符串 u1,u2,u4,u8分别代表1，2，4，8个字节 表：由无符号数或者其它表作为数据项构成描述同一类型但是数量不定的多个数据时（虚拟机不知道你到底定义了多少个），经常使用一个前置的容量计数器来告知接下来多少个是相同类型的 #魔数-咖啡宝贝class文件的前4个字节。为了确定这个文件时一个能被虚拟机接受的class文件。 #class文件版本号4字节，确定java版本 #常量池 class文件的资源仓库class文件中第一个表类型的数据项目，常量池中的常量数目不固定，因此需要一个容量计数器。常量池可以说有如下两部分：常量池容量计数器 各种常量数据 ##常量池计数器一个u2类型的数据 从 1 开始计数人（只有常量池计数器是从1开始计数，留有0是为了不引用任何常量）每一单位记录的是一个表结构，常量池中共有14种不同的常量类型即有14种表结构。这些表结构可能会相互引用，例如代表名称的会存放字符串这种表结构的引用 ##常量数据主要存放两大类（实际均为字符串）： 字面量 符号引用 标注：这里存放符号引用实现了Java的动态连接，JVM运行时据此解析翻译成具体的内存地址。 #访问标志（u2类型）用以标识该class文件的类别和访问权限。例如：存放的是类还是接口。是public还是private。 #确认继承关系的类索引：u2类型 保存该类的全限定名。父类索引：u2类型 保存其父类的全限定名 Java不允许多重继承 因此只有一个。接口索引集合： 一组u2类型的数据集合 保存该类实现的所有接口的全限定名集合。按如上顺序排列在访问标志之后 所有保存的都是常量池中的索引 #字段表集合 包括类级变量和实例变量都是字段的描述信息，不会列出从超类或者父类中继承而来的字段 试着来描述一个字段 会有作用域、实例还是类变量、可变性、并发性、变量类型、变量名称等等 字段计数器 u2类型 记录字段数据的数目 下面是每个数据项都会有的内容： 字段修饰符 简单名称（对常量池的引用） 描述符（对常量池的引用）：描述符的作用是用来描述字段的数据类型【针对字段】、方法的参数列表（数量，类型，顺序）和方法的返回值【针对方法】 后面是可有可无的属性表集合用以存储额外的信息。 #方法表集合和字段表集合一样是用来描述方法的有如下 访问标志 名称索引 描述符 属性表集合：方法里的Java代码经过编译器编译成字节码指令后存储在方法属性表隆重的code属性中 方法表中不会存放没重写的方法重载一个方法，除了要有相同的简单名称之外，还要求有不同的特征签名。特征签名：一个方法中各个参数在常量池中的字段符号引用的集合，返回值不再特征签名内 #属性表集合在字段表，方法表，class文件中都可以携带自己的属性表集合。限制相对宽松一点， 结构自定义，但必须含有u2类型的名称索引和长度。 Java虚拟机会忽略掉它不认识的属性 ，每个属性的名称都是从常量池中引用下面是几个常用属性： Code属性：出现在方法表中的属性集合内 属性名称 属性值长度 操作数栈深度最大值 局部变量表所需空间：局部变量表能存放的有方法的参数，catch的参数，定义的局部变量。 字节码长度： 实际有u2长度的限制，超过后编译器拒绝编译 字节码 显式异常处理表（含有四个字段）： 开始行：如果字节码在开始行与结束行之间出现了 结束行：异常类型的异常，就跳转到跳转行开始 跳转行：处理 异常类型： 编译器使用这个异常表来实现Java异常和finally处理机制。 Exceptions属性：位于方法表中。列举出方法中可能抛出的受查异常。也就是throws后列举的异常。 LineNumberTable属性：生成于class文件中。源码行号与字节码行号之间的对应关系。 LocalVariableTable属性：生成于class文件中。栈帧中的局部变量表中的变量信息。例如变量的作用域表示为：变量的开始的字节码偏移量 和 长度来表示 SourceFile属性：clss文件中。记录源码文件名称。 ConstantValue属性：作用为通知虚拟机自动为变量赋值。赋值时的情况：1 实例变量（非static）：在实例构造器中进行赋值（init（））2 类变量赋值：在类构造器中。 ConstantValue中。 Inner class属性：记录内部类与宿主类之间的关联。 StackMapTable属性：在类加载阶段的字节码验证阶段使用。内容的意义表示执行到该字节码时局部变量表和操作数栈的验证类型 上述就是我们代码经过编译后的样子，这是我们的程序开始的第一步，下一步就是如何将程序从静态的硬盘转到动态的内存中去。结尾还有彩蛋欧~ 这里来补充一点字节码指令的相关信息。JVM指令 = 操作码（一个字节长度） + 操作数JVM采用的是面向操作数栈的 因此大多数指令不含操作数字节码与数据类型：特定的操作只提供有限的类型相关指令。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java IO使用]]></title>
    <url>%2F2018%2F09%2F07%2Fjava-IO%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[总述我们需要将数据从一端接收到另一端来使用，宏观上说我们需要的要么是一些数字啊文本啊来进行我们预期的处理，这些数据要么是存放在硬盘中（文件），要么是我们从键盘获取，但都是要交给程序来使用。这其中有两个问题： 从哪里拿（写到哪里）。&emsp;理想的就是有一个地方，我们要接收就从这个地方获取，要输送就将数据写进这个地方中，多么方便，这个地方就是流。 如何去拿（按照什么方式去写）。 &emsp;解决了 从哪里 的问题，就要说我们如何去获取，也就是按照什么方式去接收或者发送这些数据。比如说我们要按照字符串接受，或者我们要以整形的形式来接收等等。这都是我们要使用的方式。这里涉及到后面的装饰器模式。 你应该知道: 文件的读写一般需要两次数据复制,第一次是将数据从硬盘复制到 打开文件：会在操作系统的内核中建立一个内存结构，该内存结构消耗内存，因此可以同时打开的内存有限。 关闭文件：同步缓冲区内容到硬盘并释放内存结构。 流使用同一种概念来处理所有IO，屏蔽不同。换一中方式理解，流就是一个通道，里面装着数据流，从源端到接受端。数据流有字节流和字符流之分，不同就是每次读或者写的单位不同。 #####装饰器模式通过叠合多个对象来提供所期望的功能。功能可以理解成按照何种方式换句话说就是对基本的流增加功能，但是每一个增加功能的类只注重一个方面。如下： 字节流 以InputStream OutputStream 作为基类 有增加缓冲功能的： Buffered(Input / Output)Stream 规格化为按照基本类型或者String来处理：Data(Input / Output)Stream 将基本类型，对象按照字符串输出：PrintStream 字符流 以Writer Reader 作为基类 读写文件的：File(Reader/Writer) 带有缓冲的：Buffered(Reader/Writer)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令记录]]></title>
    <url>%2F2018%2F09%2F05%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[git入门命令 什么是Git，GitHub？ &nbsp;&nbsp;&nbsp;&nbsp;纯属个人理解，如有雷到，见谅见谅。。。。&nbsp;&nbsp;&nbsp;&nbsp;说的通俗一点，GitHub就是一个来存放文本文件的地方（类比网盘），它是远程服务器我们的电脑是客户端。两个地方是不是的同步一下数据来保证我们两个地方保存的东西都一样。既然如此我们就直接使用平时的网盘来保存我们的代码何必使用git或者github呢。因为它有版本控制功能，它记录了我们对文本文件的操作流水账，比如：加了哪些东西，在那些个文件中加的，在哪里做了修改等等，我们可以把不同的操作结果叫做不同的版本，每个版本有自己的版本号，我们可以在版本号列表中选择恢复到任何记录在案的版本。 刚刚下载安装git后需要设置连接用户：12git config --global user.namegit config --golbal user.email 创建版本库，即使之可以被版本管理： git init //初始化，git可管理 往简单说只需三步你就可以将本地库同步到远程：1231. git add //此命令表示将更改提交到暂存区2. git commit -m &quot;此次提交的说明性文字&quot; //表示将更改提交到仓库3. git push //此命令为省略，只是来表示为push命令，新手切勿直接使用，将本地提交到远程 到此会有疑问，什么暂存区什么仓库，如下说明：工作区：就是你在电脑上看到的目录。版本库：就是该目录下的 .git目录，在不懂的情况下不要随意改动。暂存区： 暂存区存放与版本库中，即在 .git目录中。补充：.git 中也存放着默认创建的master分支，和指向master的指针HEAD。 git status——查看有什么被修改：用来显示工作目录和暂存区的状态，不显示已经提交(git commit)到历史中的信息 git status //闲着没事就 git status 一下 你会看到有三类（个人理解）：1.Changes to be committed : 所有的都准备好了，可以被 git commit 了。2.Changes not staged for commit: 你修改过文件，需要git add一下。&ensp;&ensp;&ensp;&ensp;&ensp;就像是：喂，我知道你做过修改，过来给我报备一下，我要记录在案3.Untracked files: 表示这些文件好没有被版本库记录，如果要记录，你需要git add一下。 git diff + 文件名查看该文件做了什么修改。 本人没用过，不太会。。。 版本管理命令：1234567git log //按时间的由近到远的显示提交记录git reset -hard HEAD^ //恢复到上一个版本git reset -hard HEAD~N //恢复到上N个版本git reflog //显示每次提交的版本号（为一串数字，唯一存在） 查看你的本地仓库与远程库的关系：12git remotegit remote -vv 查看本地分支的追踪关系：1git branch -vv //查看本地分支与哪些分支存在追踪关系 创建并切换分支：git checkout -b 新分支的名字 //代表创建分支并切换到该分支该命令相当于git branch 新分支名字git checkout 新分支名字 与分支有关的命令： 查看有哪些分支： git branch 删除分支：git branch -d 分支名 合并分支：git merge 分支 //将指定分支合并到当前分支，一般搭配--no-ff 参数来使用 结果是禁用fast forward还有一点就是会保存下被删除分支的版本号信息，方便来恢复 参考地址：https://www.yiibai.com/git/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习]]></title>
    <url>%2F2018%2F08%2F25%2Fmarkdown%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简单轻量级的标记语法 基本用法：单个回车表示空格 连续回车表示分段 行尾加两个空格表示段内换行 可以使用HTML标签 标题使用 #每一个#代表以及标题 最多支持6级标题 例如例如例如列表使用无序列表使用（ ，+，-） 列表使用：（ ，+，-）中选一个加一个空格例如： 列表 类表 列表 列表3 列表 有序列表数字加点号再空格 音乐 数据 #嵌套 文字格式**粗体** __粗体__ 斜体*斜体* _斜体_ 删除线链接链接语法为 [你显示的](网址) 百度 将网址放在尖括号内，即网址原样生成。例如： &lt;https://silencewmy.github.io/&gt; https://silencewmy.github.io/ 图片语法： ！[替代文本]（链接地址 &quot;&quot;） 引用 一级引用 二级引用 三级引用 目录在要生成目录的地方写 [TOC]或者[toc]，同时大写或小写。 水平分割线一串‘-’或者‘*’ 表格表头 | 表头 | 表头 :-----| -------:|:-----: 内容 | 内容 | 内容 :– 左对齐，–: 表示右对齐， :–: 居中 效果图： 表头 表头 表头 内容 内容 内容 内容 内容 内容 #文档头规范 title：文章标题 date：文章创建时间 categoties：分类 tags： 标签 toc： true or false 是否显示目录需要 top：填数字，和优先级差不多意思 description：文章摘要 comments：是否允许评论 keywords：文章关键字]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>

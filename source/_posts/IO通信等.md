---
title: JavaIO通信
date: 2019-03-10 10:42:42
tags:  Java IO
categories: 技术
---


Java异步阻塞等通信方式介绍


<!--more-->

同步与异步：
多个任务或者事件发生，其中某个事件的发生会不会导致其他事件的等待，导致整个流程不能继续执行。同步就是必须按照顺序执行，每个事件会对其他事件有影响，所以没有办法并发执行。异步：指这些事件相互之间没有影响，因此可以并发的执行。

阻塞非阻塞：
当某个事件在执行过程中，所需要的某个条件没有满足，整个过程停止下来，等待这个条件满足后在往下执行，就是阻塞。而非阻塞就是在条件不满足的情况下，会得到不满足的信号，因此可以让这个执行过程感知到，这样它就可以使用CPU去做不用这个条件的是事。


阻塞IO和非阻塞IO：
首先是IO操作：对数据到内存的写入和写出。
IO操作的过程是（以读操作为例）：用户线程发起IO请求操作，收到后内核就会查看要读取的消息是否就绪。等到就绪后，内核将数据拷贝到用户线程（内核进行数据拷贝的过程中都会让用户线程阻塞，除了异步IO）。
阻塞IO就是在数据没有就绪的时候，一直等待在那里，直到数据拷贝到所在线程。
而非阻塞IO就是：在数据没有就绪的时候，内核会返回标志性信息给用户线程数据告知数据没有就绪。因此用户线程可以进行其他调度。。

同步IO和异步IO：
同步IO是：一个线程请求IO操作，在该IO操作完成之前，线程会被阻塞。
异步IO：IO操作不会导致线程阻塞。
造成上述结果是因为要不要使用用户线程。
对于同步IO，IO操作如果数据没有就绪，就需要用户线程或者内核不断轮询数据是否就绪，就绪后内核将数据拷贝到用户线程。
对于异步IO来说：只有请求IO操作是由用户线程完成，轮询信息状态和拷贝数据都是有内核来完成。不会使用用户线程。
因此异步IO必须要有操作系统的底层支持（内核来完成一些事情）。


五种IO模型：
阻塞IO：读写数据过程中会发生阻塞现象。数据没有就绪，用户线程会阻塞交出CPU，直到数据背靠背到用户线程。


非阻塞IO：发起IO请求后会立刻得到结果，来分辨数据有无准备好。想要获得数据就需要用户线程轮询是否就绪。


多路复用IO：Java NIO就是使用的多路复用。通过一个线程来轮询所有的状态是否就绪。就绪后才开始需要这个数据的用户线程的真正的IO操作。这样只会使用一个线程的资源。轮询状态是由内核来完成的。通过轮询来检查状态的满足情况，因此，大范围满足时，导致后面事件不能及时处理。

信号驱动IO：用户发起IO请求后留下信号函数（可以理解为联系方式：其中有实际的后续的IO操作），用户线程就会离开做其他的事，数据就绪后内核通知用户线程，收到信号后，用户线程调用信号函数中的后续的IO操作函数（需要用到用户线程）。

异步IO：用户线程发起IO请求后就去做其他的事情。整个IO由内核来完成，收到请求后，立刻返回说”收到任务“，然后等待数据就绪，再将数据拷贝到用户线程。这两步做完后，内核告知用户线程IO操作完成了，数据可以直接使用了。



Reactor和Proactor模式

Reactor模式:将所有要监管的对象（统称做对象，Java 万物皆对象）进行所关注的事件进行分类，改为每类轮询自己这一类事件的对象。

Proactor模式:将IO操作交由内核来完成。检测到事件发生时，交由内核来处理，内核处理完后告知操作完成。






接下来说 Java NIO：
Java NIO是面向缓冲区的。数据的读或者写都要经过缓冲区(因为缓冲区的读写是可以立刻执行完的，因此不需要等待)，使用一个线程（叫做选择器）来在多个需要IO操作的不同对象间选择哪些可以立马从缓冲区处理数据的对象。



学习自  
海子的博客：<https://www.cnblogs.com/dolphin0520/p/3916526.html>

平凡希：<https://www.cnblogs.com/xiaoxi/p/6576588.html>

Geason崔:<https://www.cnblogs.com/geason/p/5774096.html>


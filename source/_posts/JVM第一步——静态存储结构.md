---
title: JVM第一步——静态存储结构
date: 2018-10-18 00:11:08
tags: java
categories: 技术
---
我们平时看到的运行java程序实际上经历了几次转换。
<!--more-->

#引导
**java 能成为跨平台语言得益于它增加了一层中间码---字节码。**我们知道操作系统不同代表它的操作指令的不同，而编程语言是要转换成能操作机器的机器指令才能运行。 这就使得在不同操作系统上运行同样的代码，你就要重新编译成该系统能够识别的操作指令。而虚拟机的作用就是屏蔽这些差异，它会根据相同的代码调用适合该操作系统的指令。虚拟机只识别字节码，不管什么操作系统你只要给我字节码我就可以识别(当然，不同的操作系统使用的虚拟机是不同的)。正是虚拟机这种**只识别一种格式的文件但能调用不同的指令实现相同的功能**的特性使得java语言可以“一次编写，到处运行”。保存我们的可运行程序也就是在磁盘中保存字节码文件(**.class文件**)。我们知道字节码文件格式后就知道了是如何和我们编写的java代码一一对应的了。下面进入正题。   

----------------------------------------------------------------------------------------------------------------------------------------------
######不容有错  
文件肯定是二进制字节流。class文件也是但它没有分隔符，并且它需要你按照严格的顺序排列在其中，这样它就知道哪部分是什么含义。因此无论顺序、数量，那个字节代表什么含义，长度是多少，先后顺序都是严格限定的，不容有错、有变。


#文件中的类型  
class文件使用类似于C语言中的结构体的伪结构来存储数据，通篇只有两种类型： 
* 无符号数：用来描述数字、索引引用、数量值、或者UTF-8编码的值的字符串 u1,u2,u4,u8分别代表1，2，4，8个字节  
* 表：由无符号数或者其它表作为数据项构成  
 *描述同一类型但是数量不定的多个数据时（虚拟机不知道你到底定义了多少个），经常使用一个前置的容量计数器来告知接下来多少个是相同类型的*


#魔数-咖啡宝贝  
class文件的前4个字节。为了确定这个文件时一个能被虚拟机接受的class文件。

#class文件版本号  
4字节，确定java版本

#常量池 class文件的资源仓库
class文件中第一个表类型的数据项目，常量池中的常量数目不固定，因此需要一个容量计数器。常量池可以说有如下两部分：  
*常量池容量计数器  
*各种常量数据
##常量池计数器
一个u2类型的数据 从 ***1*** 开始计数人（只有常量池计数器是从1开始计数，留有0是为了不引用任何常量）  
每一单位记录的是一个表结构，常量池中共有14种不同的常量类型即有14种表结构。  
这些表结构可能会相互引用，例如代表名称的会存放字符串这种表结构的引用
##常量数据  
主要存放两大类（实际均为字符串）：

* 字面量
* 符号引用  
    *标注：这里存放符号引用实现了Java的动态连接，JVM运行时据此解析翻译成具体的内存地址。*

#访问标志（u2类型）
用以标识该class文件的类别和访问权限。  
例如：存放的是类还是接口。是public还是private。

#确认继承关系的  
**类索引**：u2类型 保存该类的全限定名。  
**父类索引**：u2类型 保存其父类的全限定名 Java不允许多重继承 因此只有一个。  
**接口索引集合**： 一组u2类型的数据集合 保存该类实现的所有接口的全限定名集合。  
*按如上顺序排列在访问标志之后 所有保存的都是常量池中的索引*

#字段表集合 包括类级变量和实例变量  
***都是字段的描述信息，不会列出从超类或者父类中继承而来的字段 试着来描述一个字段 会有作用域、实例还是类变量、可变性、并发性、变量类型、变量名称等等***  

* 字段计数器 u2类型 记录字段数据的数目

下面是每个数据项都会有的内容：  

* 字段修饰符
* 简单名称（对常量池的引用）
* 描述符（对常量池的引用）：描述符的作用是**用来描述字段的数据类型【针对字段】、方法的参数列表（数量，类型，顺序）和方法的返回值【针对方法】**   
* 后面是可有可无的属性表集合用以存储额外的信息。

#方法表集合  
***和字段表集合一样是用来描述方法的有如下*** 

* 访问标志
* 名称索引
* 描述符
* 属性表集合：方法里的Java代码经过编译器编译成字节码指令后存储在方法属性表隆重的code属性中

*方法表中不会存放没重写的方法*  
*重载一个方法，除了要有**相同**的简单名称之外，还要求有**不同**的特征签名。*  
**特征签名：一个方法中各个参数在常量池中的字段符号引用的集合，返回值不再特征签名内**

#属性表集合  
*在字段表，方法表，class文件中都可以携带自己的属性表集合。限制相对宽松一点，* **结构自定义，但必须含有u2类型的名称索引和长度。   Java虚拟机会忽略掉它不认识的属性**   *，每个属性的名称都是从常量池中引用*  
下面是几个常用属性：

* Code属性：**出现在方法表中的属性集合内**
    * 属性名称
    * 属性值长度
    * 操作数栈深度最大值
    * 局部变量表所需空间：局部变量表能存放的有**方法的参数，catch的参数，定义的局部变量。**
    * 字节码长度： 实际有u2长度的限制，超过后编译器拒绝编译
    * 字节码
    * 显式异常处理表（含有四个字段）：
        * 开始行：如果字节码在**开始行**与**结束行**之间出现了
        * 结束行：**异常类型**的异常，就跳转到**跳转行**开始
        * 跳转行：处理
        * 异常类型：  编译器使用这个异常表来实现Java异常和finally处理机制。
* Exceptions属性：**位于方法表中。**列举出方法中可能抛出的受查异常。也就是throws后列举的异常。
* LineNumberTable属性：**生成于class文件中。**源码行号与字节码行号之间的对应关系。
* LocalVariableTable属性：**生成于class文件中。**栈帧中的局部变量表中的变量信息。例如变量的作用域表示为：变量的开始的字节码偏移量 和 长度来表示
* SourceFile属性：clss文件中。记录源码文件名称。
* ConstantValue属性：作用为通知虚拟机自动为变量赋值。  
 赋值时的情况：  
 1 实例变量（非static）：在实例构造器中进行赋值（init（））   
2 类变量赋值：在类构造器中。  ConstantValue中。

* Inner class属性：记录内部类与宿主类之间的关联。
* StackMapTable属性：在类加载阶段的**字节码验证**阶段使用。内容的意义表示执行到该字节码时局部变量表和操作数栈的验证类型


上述就是我们代码经过编译后的样子，这是我们的程序开始的第一步，下一步就是如何将程序从静态的硬盘转到动态的内存中去。结尾还有彩蛋欧~


******************************************

这里来补充一点字节码指令的相关信息。  
JVM指令 = 操作码（一个字节长度） + 操作数  
JVM采用的是面向操作数栈的 因此大多数指令不含操作数
字节码与数据类型：特定的操作只提供有限的类型相关指令。
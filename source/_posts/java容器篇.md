---
title: java容器篇
date: 2018-10-18 13:06:29
tags: java
---

java的容器主要有三种：  

* map 键值对，其中键无重复
* set 一种类似数学中集合的概念，要求元素无重复
* 数组和链表

<!--more-->


**Arraylist 动态数组类型容器 泛型容器**   
主要方法 add get等等  
**基本原理：内部维持着一个总有空闲的数组和实际元素的个数，期间动态修改数组大小。增加元素时整体复制。内部会记录容器的修改次数。**
总结：内部采用**动态数组**实现，按索引**访问效率较高**。非线性安全，增加时复制全部，删除时移动后一部分。
迭代器：关注分离的思想，数据的迭代与数据的组织方式分离。**在迭代过程中不可发生结构性变化**（例如上面的记录修改次数，每次迭代时比较不同时刻的该值来实现检查有无结构性变化）

Vector：基本原理与arraylist相同但是有使用重量级锁synchronized关键字来保证线程安全。

**LinkedList：内部实现为双向链表**  
具有三个实例变量。按需求分配空间，两端插入删除效率高，中间相对较低（因为需要比较来进行定位）。

**ArrayDuque:内部实现为循环数组。**内部数组保证为2的幂次方，通过位操作来判断与找到正确的位置。两端操作效率较高。

上述三种基于**数组或者链表的具有顺序的容器按照内容来查找元素效率都很低，因为其需要逐个比较。**

接下来是Map与set的实现类：

**Map接口：键值对。按照键存储与访问值。键不能重复，相同的键会覆盖原值**

**Set接口：表示集合中数学中集合的概念。没有定义新的方法，但是有语义约束--不能有重复元素。（后面的很多set实现类的内部都是使用的Map的键来实现元素的唯一）**

**HashMap：根据键操作值，键值对无序。**

HashMap:内部具有如下四个实例变量:

* 实际键值对个数的 size
* 阈（yu）值：size值大于此值会考虑扩展 哈希表数组
* 负载因子：表示下面的哈希表数组中被占用程度。
* Entry类型的table（就是一个数组，叫做哈希表），Entry类型为内部定义一个类{类中有 键，值，指向下一个节点的值，键的hash值}。这个数组中的元素指向一个单向链表，链表中的每个节点表示一个键值对。

HashMap中保存键值对的过程为：
```
第一次保存 --(key不为空)--> 计算key的hash值 --(找到table中相应的位置)
|-->(table中有空间)-->在表头插入  
|-->(table中没有空间)-->扩展空间--->将原来的键值对移动过来并计算新的位置。                                                       

```

HashMap中的长度为2的幂次方。 

**HashMap中的查找**：先找到table中的位置，然后在链表中遍历查找。

**HashMap原理总结：内部有一个哈希表数组，其中元素指向一个单向链表，根据键的hash值找到链表，然后操作该链表。大量元素映射到同一个链表下时，将链表转化为平衡二叉树。**

**HashMap使用总结：根据键来操作值，效率较高。不是线程安全的。使用重量级锁来实现线程安全的HashTable。实现原理相同。如果要保持添加顺序则使用HashMap的子类LinkedHashMap。**

**LinkedHashMap**：可以按照**插入**或者按照**访问**来排序。默认是按照插入来排序。HashMap的子类。

访问顺序：最开始是最求没被访问的，最末尾的是最近访问的。

使用场景：

* 插入排序：
    - 需要按照输入顺序来输出，比如配置文件
    - 希望保持添加顺序，比如购物车
    - 输入数据本来就按照键排好序。

* 访问顺序：
    - 构成LRU缓存   只有一个构造方法来使用访问排序。

**内部原理：是HashMap的子类，但内部还有一个双向链表来维持键值对的顺序，也就是说同一个键值对既在哈希表中又在双向链表中。**


 
**HashSet：元素无序，无重复。** 应用场景：排重，保存特殊值， 集合运算。

**实现原理：**内部有一个HashMap，HashMap有键值对，HashSet中只有键，值是相同的值。
总结：无重复元素，高效的增删，判断存在。元素无顺序。如果要保持添加顺序，使用LinkedHashSet。

**LinkedHashSet：按照添加顺序保存顺序。**  
内部实现为LinkedHashMap。



**TreeMap：键值对之间按键有序。**

**实现原理：内部使用红黑树实现。**
TreeMap具有如下实例变量：

*  长度
* 比较器
* 内部类型Entry：
    * 键
    * 值
    * 左右孩子父节点
    * 颜色

**总结：按键有序，但要求键实现comparable接口或者comparator对象来实现比较。**



**TreeSet：有序，无重复。**可以来排重。

**实现原理：**基于TreeMap来实现，键为元素，值位同一值，无重复（Map接口的要求）。
